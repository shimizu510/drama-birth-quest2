<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DramaBirthQuest Web Uploader</title>
  <link rel="preconnect" href="https://cdn.apple-mapkit.com" crossorigin>
  <script src="https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Helvetica Neue", Arial, sans-serif;
      --accent: #6c4cff;
      --bg: #f5f5f7;
      --bg-dark: #1c1c1e;
      --card: rgba(255, 255, 255, 0.85);
      --card-dark: rgba(28, 28, 30, 0.85);
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, rgba(108, 76, 255, 0.2), rgba(0, 199, 190, 0.2)), var(--bg);
      color: #1f1f1f;
      display: flex;
      flex-direction: column;
    }

    body.dark {
      background: linear-gradient(135deg, rgba(108, 76, 255, 0.35), rgba(0, 199, 190, 0.35)), var(--bg-dark);
      color: #f5f5f7;
    }

    header {
      padding: 2rem clamp(1rem, 4vw, 3rem) 1.5rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2rem, 5vw, 3.5rem);
      font-weight: 700;
      color: var(--accent);
    }

    header p {
      margin-top: 0.75rem;
      font-size: clamp(1rem, 2.5vw, 1.25rem);
      line-height: 1.6;
    }

    main {
      flex: 1 1 auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: clamp(1.5rem, 3vw, 2.5rem);
      padding: 0 clamp(1rem, 4vw, 3rem) 3rem;
    }

    .card {
      background: var(--card);
      border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(10px);
      padding: clamp(1.25rem, 3vw, 2rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    body.dark .card {
      background: var(--card-dark);
    }

    h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--accent);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    label {
      font-size: 0.95rem;
      font-weight: 600;
      display: block;
      margin-bottom: 0.4rem;
    }

    input[type="text"],
    input[type="number"],
    input[type="url"],
    textarea,
    select {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 12px;
      border: 1px solid rgba(31, 31, 31, 0.15);
      background: rgba(255, 255, 255, 0.9);
      font-size: 0.95rem;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    body.dark input,
    body.dark textarea,
    body.dark select {
      background: rgba(44, 44, 46, 0.8);
      border-color: rgba(245, 245, 247, 0.2);
      color: inherit;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108, 76, 255, 0.2);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .map-wrapper {
      border-radius: 14px;
      overflow: hidden;
      height: 320px;
      position: relative;
      background: rgba(0, 0, 0, 0.05);
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button.primary {
      background: linear-gradient(135deg, #6c4cff, #00c7be);
      color: white;
      box-shadow: 0 14px 30px rgba(108, 76, 255, 0.35);
    }

    button.secondary {
      background: rgba(108, 76, 255, 0.1);
      color: var(--accent);
    }

    button.danger {
      background: rgba(255, 99, 132, 0.12);
      color: #ff496a;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.12);
    }

    .flex-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .flex-row .field {
      flex: 1 1 160px;
    }
    .dialogue-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .dialogue-header p {
      margin: 0.25rem 0 0;
      font-size: 0.9rem;
      color: rgba(31, 31, 31, 0.7);
    }

    .dialogue-header h3 {
      margin: 0;
      font-size: 1.05rem;
    }

    body.dark .dialogue-header p {
      color: rgba(245, 245, 247, 0.7);
    }

    .dialogue-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .dialogue-row {
      border: 1px solid rgba(31, 31, 31, 0.12);
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.85);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    body.dark .dialogue-row {
      border-color: rgba(245, 245, 247, 0.16);
      background: rgba(44, 44, 46, 0.75);
    }

    .dialogue-row .flex-row {
      gap: 0.75rem;
    }

    .dialogue-row textarea {
      min-height: 90px;
    }

    .dialogue-row-actions {
      display: flex;
      justify-content: flex-end;
    }

    .dialogue-row-actions .danger {
      padding-inline: 1rem;
    }

    pre#quest-preview {
      background: rgba(0, 0, 0, 0.75);
      color: #f5f5f5;
      border-radius: 12px;
      padding: 1rem;
      max-height: 280px;
      overflow: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .log {
      font-size: 0.85rem;
      line-height: 1.4;
      white-space: pre-wrap;
      min-height: 2.5rem;
    }

    footer {
      text-align: center;
      padding: 1.5rem;
      font-size: 0.85rem;
      color: rgba(31, 31, 31, 0.6);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
      }

      body:not(.light) {
        background: linear-gradient(135deg, rgba(108, 76, 255, 0.35), rgba(0, 199, 190, 0.35)), var(--bg-dark);
        color: #f5f5f7;
      }

      footer {
        color: rgba(245, 245, 247, 0.6);
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>DramaBirthQuest Web Uploader</h1>
    <p>3DAdventureのクエストをウェブ上で設計し、Swiftアプリのクエスト作成画面と同じ構成でシナリオを組み立てられます。<br>
      MapKitで配置したロケーション情報と合わせてアップロードまたはJSONとしてエクスポートしましょう。</p>
  </header>

  <main>
    <section class="card" aria-labelledby="mapkit-setup">
      <h2 id="mapkit-setup">MapKit 設定</h2>
      <p>MapKit JSのJWTトークンを入力してマップを初期化してください。トークンを持っていない場合は、<a href="https://developer.apple.com/documentation/mapkitjs" target="_blank" rel="noopener">Apple Developer</a>で発行できます。</p>
      <label for="mapkit-token">MapKit JWT</label>
      <input id="mapkit-token" type="text" placeholder="eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9...">
      <div class="button-row">
        <button class="primary" type="button" id="mapkit-init">Mapを初期化</button>
        <button class="secondary" type="button" id="toggle-theme">ライト/ダーク切替</button>
      </div>
      <div class="map-wrapper" role="region" aria-label="クエスト設置用マップ">
        <div id="map"></div>
      </div>
      <div class="flex-row">
        <div class="field">
          <label for="latitude">緯度 (Latitude)</label>
          <input id="latitude" type="number" step="any" placeholder="35.6809591">
        </div>
        <div class="field">
          <label for="longitude">経度 (Longitude)</label>
          <input id="longitude" type="number" step="any" placeholder="139.7673068">
        </div>
        <div class="field">
          <label for="regionRadius">表示範囲 (m)</label>
          <input id="regionRadius" type="number" min="100" value="500">
        </div>
      </div>
      <p class="log" id="map-log">マップが未初期化です。JWTを入力して「Mapを初期化」を押してください。</p>
    </section>

    <section class="card" aria-labelledby="quest-settings">
      <h2 id="quest-settings">クエスト設定</h2>
      <label for="quest-title">タイトル</label>
      <input id="quest-title" type="text" placeholder="例: 失われた記憶のかけら">

      <div class="dialogue-section">
        <div class="dialogue-header">
          <h3>セリフ &amp; キャラクター配置</h3>
          <p>Swiftアプリの「キャラ配置」UIと同じく、キャラクターを左・中央・右のいずれかに配置し、セリフを設定します。</p>
        </div>
        <div id="dialogue-list" class="dialogue-list" role="list"></div>
        <div class="button-row">
          <button class="secondary" type="button" id="add-dialogue">セリフを追加</button>
          <button class="secondary" type="button" id="clear-form">シナリオをクリア</button>
        </div>
      </div>

      <label for="quest-preview">JSONプレビュー</label>
      <pre id="quest-preview" aria-live="polite">{
  "title": "",
"script": [],
  "location": {
    "latitude": null,
    "longitude": null,
    "radius": 500
  }
}</pre>
    </section>

    <section class="card" aria-labelledby="upload-section">
      <h2 id="upload-section">アップロード &amp; エクスポート</h2>
      <label for="upload-endpoint">クエストAPIエンドポイント</label>
      <input id="upload-endpoint" type="url" placeholder="https://example.com/api/quests">

      <label for="upload-token">認証トークン (必要な場合)</label>
      <input id="upload-token" type="text" placeholder="Bearer ...">

      <div class="button-row">
        <button class="primary" type="button" id="upload-quest">アップロード</button>
        <button class="secondary" type="button" id="download-quest">JSONをダウンロード</button>
        <button class="danger" type="button" id="reset-all">すべてリセット</button>
      </div>

      <p class="log" id="upload-log">アップロード結果がここに表示されます。</p>
    </section>
  </main>

  <footer>
    3DAdventure Quest Builder &copy; 2025 — Swift版のロジックに合わせたJSONスキーマを採用しています。
  </footer>

  <script>
    const state = {
      map: null,
      marker: null,
      selectedCoordinate: null,
      dialogueCounter: 0
    };

    const mapLog = document.getElementById('map-log');
    const uploadLog = document.getElementById('upload-log');
    const questPreview = document.getElementById('quest-preview');

    const latitudeInput = document.getElementById('latitude');
    const longitudeInput = document.getElementById('longitude');
    const radiusInput = document.getElementById('regionRadius');

    const questFields = {
title: document.getElementById('quest-title')
    };
    const dialogueList = document.getElementById('dialogue-list');
    const addDialogueButton = document.getElementById('add-dialogue');

    function createDialogueRow(data = {}) {
      state.dialogueCounter += 1;
      const row = document.createElement('div');
      row.className = 'dialogue-row';
      row.setAttribute('role', 'listitem');

      const charId = `dialogue-character-${state.dialogueCounter}`;
      const posId = `dialogue-position-${state.dialogueCounter}`;
      const lineId = `dialogue-line-${state.dialogueCounter}`;

      const flex = document.createElement('div');
      flex.className = 'flex-row';

      const charField = document.createElement('div');
      charField.className = 'field';
      const charLabel = document.createElement('label');
      charLabel.setAttribute('for', charId);
      charLabel.textContent = 'キャラクター名';
      const charInput = document.createElement('input');
      charInput.type = 'text';
      charInput.id = charId;
      charInput.placeholder = '例: リナ';
      charInput.classList.add('dialogue-character');
      charField.appendChild(charLabel);
      charField.appendChild(charInput);

      const posField = document.createElement('div');
      posField.className = 'field';
      const posLabel = document.createElement('label');
      posLabel.setAttribute('for', posId);
      posLabel.textContent = '配置';
      const posSelect = document.createElement('select');
      posSelect.id = posId;
      posSelect.classList.add('dialogue-position');
      [
        { value: 'left', label: '左' },
        { value: 'center', label: '中央' },
        { value: 'right', label: '右' }
      ].forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        posSelect.appendChild(opt);
      });
      posField.appendChild(posLabel);
      posField.appendChild(posSelect);

      flex.appendChild(charField);
      flex.appendChild(posField);

      const lineLabel = document.createElement('label');
      lineLabel.setAttribute('for', lineId);
      lineLabel.textContent = 'セリフ';
      const lineTextarea = document.createElement('textarea');
      lineTextarea.id = lineId;
      lineTextarea.placeholder = 'キャラクターのセリフを入力';
      lineTextarea.classList.add('dialogue-line');

      const actions = document.createElement('div');
      actions.className = 'dialogue-row-actions';
      const removeButton = document.createElement('button');
      removeButton.type = 'button';
      removeButton.classList.add('danger');
      removeButton.textContent = 'このセリフを削除';
      actions.appendChild(removeButton);

      row.appendChild(flex);
      row.appendChild(lineLabel);
      row.appendChild(lineTextarea);
      row.appendChild(actions);
      dialogueList.appendChild(row);

      const applyData = () => {
        charInput.value = data.character || '';
        posSelect.value = data.position || 'center';
        lineTextarea.value = data.dialogue || '';
      };
      applyData();

      const handleChange = () => {
        if (state.marker && state.map && typeof mapkit !== 'undefined') {
          state.marker.title = questFields.title.value || 'クエストポイント';
        }
        renderQuestPreview();
      };

      charInput.addEventListener('input', handleChange);
      posSelect.addEventListener('change', handleChange);
      lineTextarea.addEventListener('input', handleChange);

      removeButton.addEventListener('click', () => {
        if (dialogueList.childElementCount <= 1) {
          charInput.value = '';
          posSelect.value = 'center';
          lineTextarea.value = '';
        } else {
          dialogueList.removeChild(row);
        }
        renderQuestPreview();
      });

      renderQuestPreview();
      return row;
    }

    function readDialogueRows(includeIncomplete = true) {
      const rows = Array.from(dialogueList.querySelectorAll('.dialogue-row')).map(row => {
        const character = row.querySelector('.dialogue-character')?.value.trim() || '';
        const position = row.querySelector('.dialogue-position')?.value || 'center';
        const dialogue = row.querySelector('.dialogue-line')?.value.trim() || '';
        return { character, position, dialogue };
      });
      return includeIncomplete ?
        rows.filter(entry => entry.character || entry.dialogue) :
        rows.filter(entry => entry.character && entry.dialogue);
    }

    function resetDialogues() {
      dialogueList.innerHTML = '';
      state.dialogueCounter = 0;
      createDialogueRow();
    }

    addDialogueButton.addEventListener('click', () => {
      const row = createDialogueRow();
      const input = row.querySelector('.dialogue-character');
      if (input) {
        input.focus();
      }
    });

    document.getElementById('toggle-theme').addEventListener('click', () => {
      document.body.classList.toggle('dark');
    });

    document.getElementById('mapkit-init').addEventListener('click', () => {
      const token = document.getElementById('mapkit-token').value.trim();
      if (!token) {
        mapLog.textContent = 'JWTが入力されていません。Apple Developerで発行したトークンを入力してください。';
        return;
      }

      if (typeof mapkit === 'undefined') {
        mapLog.textContent = 'MapKit JSが読み込まれていません。ネットワーク接続やスクリプトURLを確認してください。';
        return;
      }

      try {
        mapkit.init({
          authorizationCallback: done => {
            done(token);
          }
        });

        state.map = new mapkit.Map('map', {
          colorScheme: document.body.classList.contains('dark') ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light
        });

        state.map.addEventListener('singleTap', event => {
          const { latitude, longitude } = event.coordinate;
          setQuestLocation(latitude, longitude);
        });

        const lat = parseFloat(latitudeInput.value) || 35.6809591;
        const lon = parseFloat(longitudeInput.value) || 139.7673068;
        const radius = parseFloat(radiusInput.value) || 500;
        focusMap(lat, lon, radius);
        mapLog.textContent = `マップを初期化しました。現在地: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      } catch (error) {
        console.error(error);
        mapLog.textContent = 'MapKitの初期化に失敗しました。ブラウザのコンソールでエラーを確認してください。';
      }
    });

    function focusMap(latitude, longitude, radius) {
      if (!state.map || typeof mapkit === 'undefined') return;
      const coord = new mapkit.Coordinate(latitude, longitude);
      state.map.setRegion(new mapkit.CoordinateRegion(coord, new mapkit.CoordinateSpan(radius / 111000, radius / 111000)));
      setQuestLocation(latitude, longitude);
    }

    function setQuestLocation(latitude, longitude) {
      state.selectedCoordinate = { latitude, longitude };
      latitudeInput.value = latitude.toFixed(6);
      longitudeInput.value = longitude.toFixed(6);

      if (state.marker) {
        if (state.map && typeof mapkit !== 'undefined') {
          state.map.removeAnnotation(state.marker);
        }
        state.marker = null;
      }

      if (state.map && typeof mapkit !== 'undefined') {
        state.marker = new mapkit.MarkerAnnotation(new mapkit.Coordinate(latitude, longitude), {
          title: questFields.title.value || 'クエストポイント',
          subtitle: 'タップで再設定できます',
          color: '#6c4cff'
        });
        state.map.addAnnotation(state.marker);
      }

      renderQuestPreview();
    }

    latitudeInput.addEventListener('change', () => {
      const lat = parseFloat(latitudeInput.value);
      const lon = parseFloat(longitudeInput.value);
      const radius = parseFloat(radiusInput.value) || 500;
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        focusMap(lat, lon, radius);
        mapLog.textContent = `緯度経度を手動設定: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      }
    });

    longitudeInput.addEventListener('change', () => {
      const lat = parseFloat(latitudeInput.value);
      const lon = parseFloat(longitudeInput.value);
      const radius = parseFloat(radiusInput.value) || 500;
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        focusMap(lat, lon, radius);
        mapLog.textContent = `緯度経度を手動設定: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      }
    });

    radiusInput.addEventListener('change', () => {
      const radius = parseFloat(radiusInput.value) || 500;
      if (state.selectedCoordinate) {
        focusMap(state.selectedCoordinate.latitude, state.selectedCoordinate.longitude, radius);
        renderQuestPreview();
      }
    });

    Object.values(questFields).forEach(field => {
      field.addEventListener('input', () => {
        if (state.marker && state.map && typeof mapkit !== 'undefined') {
          state.marker.title = questFields.title.value || 'クエストポイント';
        }

        renderQuestPreview();
      });
    });



    document.getElementById('upload-quest').addEventListener('click', async () => {
      const quest = collectQuest();
      if (!quest) {
        uploadLog.textContent = '必須項目が不足しています。タイトル、セリフ、位置を確認してください。';
        return;
      }

      const endpoint = document.getElementById('upload-endpoint').value.trim();
      if (!endpoint) {
        uploadLog.textContent = 'アップロード先エンドポイントを入力してください。';
        return;
      }

      const token = document.getElementById('upload-token').value.trim();

      uploadLog.textContent = 'クエストをアップロードしています...';
      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(token ? { 'Authorization': token } : {})
          },
          body: JSON.stringify(quest)
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`${response.status} ${text}`);
        }

        uploadLog.textContent = 'アップロードに成功しました。Swiftアプリからも取得できることを確認してください。';
      } catch (error) {
        console.error(error);
        uploadLog.textContent = `アップロードに失敗しました: ${error.message}`;
      }
    });

    document.getElementById('download-quest').addEventListener('click', () => {
      const quest = collectQuest();
      if (!quest) {
        uploadLog.textContent = 'タイトル、セリフ、位置が揃っていないため、ダウンロードできません。';
        return;
      }

      const blob = new Blob([JSON.stringify(quest, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const safeTitle = quest.title.replace(/[^a-z0-9_-]+/gi, '_').toLowerCase() || 'quest';
      a.href = url;
      a.download = `${safeTitle}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      uploadLog.textContent = 'JSONファイルをダウンロードしました。Gitやクラウドに保存してチームと共有できます。';
    });

    document.getElementById('reset-all').addEventListener('click', () => {
      Object.values(questFields).forEach(field => field.value = '');
      latitudeInput.value = '';
      longitudeInput.value = '';
      radiusInput.value = 500;
      state.selectedCoordinate = null;
      if (state.map && state.marker && typeof mapkit !== 'undefined') {
        state.map.removeAnnotation(state.marker);
        state.marker = null;
      }
      resetDialogues();
      renderQuestPreview();
      mapLog.textContent = '位置情報がリセットされました。マップで新しい地点を選択してください。';
      uploadLog.textContent = 'アップロードログをリセットしました。';
    });

    document.getElementById('clear-form').addEventListener('click', () => {
      Object.values(questFields).forEach(field => field.value = '');
            resetDialogues();
      if (state.marker && state.map && typeof mapkit !== 'undefined') {
        state.marker.title = 'クエストポイント';
      }
      renderQuestPreview();
      uploadLog.textContent = 'シナリオ入力をクリアしました。位置情報はそのままです。';
    });

    function collectQuest() {
      const title = questFields.title.value.trim();
      if (!title) return null;
      const script = readDialogueRows(false);
      if (script.length === 0) return null;
      if (!state.selectedCoordinate) return null;
      const radius = Number(radiusInput.value) || 500;
      const { latitude, longitude } = state.selectedCoordinate;
      return {
        title,
        script,
        location: {
          latitude,
          longitude,
          radius
        }
      };
    }

    function renderQuestPreview() {
      const quest = collectQuest();
      if (quest) {
        questPreview.textContent = JSON.stringify(quest, null, 2);
        return;
      }

      const radius = Number(radiusInput.value) || 500;
      const fallback = {
        title: questFields.title.value.trim(),
        script: readDialogueRows(true),
        location: state.selectedCoordinate ? {
          latitude: state.selectedCoordinate.latitude,
          longitude: state.selectedCoordinate.longitude,
          radius
        } : {
          latitude: null,
          longitude: null,
          radius
        }
      };

      questPreview.textContent = JSON.stringify(fallback, null, 2);
    }
    
resetDialogues();
    renderQuestPreview();
  </script>
</body>
</html>
