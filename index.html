<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DramaBirthQuest Web Uploader</title>
  <link rel="preconnect" href="https://cdn.apple-mapkit.com" crossorigin>
  <script src="https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Helvetica Neue", Arial, sans-serif;
      --accent: #6c4cff;
      --bg: #f5f5f7;
      --bg-dark: #1c1c1e;
      --card: rgba(255, 255, 255, 0.85);
      --card-dark: rgba(28, 28, 30, 0.85);
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, rgba(108, 76, 255, 0.2), rgba(0, 199, 190, 0.2)), var(--bg);
      color: #1f1f1f;
      display: flex;
      flex-direction: column;
    }

    body.dark {
      background: linear-gradient(135deg, rgba(108, 76, 255, 0.35), rgba(0, 199, 190, 0.35)), var(--bg-dark);
      color: #f5f5f7;
    }

    header {
      padding: 2rem clamp(1rem, 4vw, 3rem) 1.5rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2rem, 5vw, 3.5rem);
      font-weight: 700;
      color: var(--accent);
    }

    header p {
      margin-top: 0.75rem;
      font-size: clamp(1rem, 2.5vw, 1.25rem);
      line-height: 1.6;
    }

    main {
      flex: 1 1 auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      gap: clamp(1.5rem, 3vw, 2.5rem);
      padding: 0 clamp(1rem, 4vw, 3rem) 3rem;
    }

    .card {
      background: var(--card);
      border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(10px);
      padding: clamp(1.25rem, 3vw, 2rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    body.dark .card {
      background: var(--card-dark);
    }

    h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--accent);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    label {
      font-size: 0.95rem;
      font-weight: 600;
      display: block;
      margin-bottom: 0.4rem;
    }

    input[type="text"],
    input[type="number"],
    input[type="url"],
    input[type="file"],
    textarea,
    select {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 12px;
      border: 1px solid rgba(31, 31, 31, 0.15);
      background: rgba(255, 255, 255, 0.9);
      font-size: 0.95rem;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    body.dark input,
    body.dark textarea,
    body.dark select {
      background: rgba(44, 44, 46, 0.8);
      border-color: rgba(245, 245, 247, 0.2);
      color: inherit;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108, 76, 255, 0.2);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .map-wrapper {
      border-radius: 14px;
      overflow: hidden;
      height: 60vh;
      min-height: 320px;
      position: relative;
      background: rgba(0, 0, 0, 0.05);
    }

    #map-main {
      width: 100%;
      height: 100%;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button.primary {
      background: linear-gradient(135deg, #6c4cff, #00c7be);
      color: white;
      box-shadow: 0 14px 30px rgba(108, 76, 255, 0.35);
    }

    button.secondary {
      background: rgba(108, 76, 255, 0.1);
      color: var(--accent);
    }

    button.danger {
      background: rgba(255, 99, 132, 0.12);
      color: #ff496a;
    }

    button.flat {
      border-radius: 12px;
      background: rgba(108, 76, 255, 0.08);
      color: var(--accent);
      padding: 0.65rem 1rem;
      transition: background 0.2s ease;
    }

    button.flat:hover {
      background: rgba(108, 76, 255, 0.16);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.12);
    }
    
    .auth-panel {
      border: 1px solid rgba(31, 31, 31, 0.12);
      border-radius: 14px;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.6);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    body.dark .auth-panel {
      border-color: rgba(245, 245, 247, 0.2);
      background: rgba(44, 44, 46, 0.45);
    }

    .auth-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    
    .asset-library {
      border: 1px solid rgba(31, 31, 31, 0.12);
      border-radius: 14px;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.6);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    body.dark .asset-library {
      border-color: rgba(245, 245, 247, 0.2);
      background: rgba(44, 44, 46, 0.45);
    }

    .asset-library-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .asset-library-header-title {
      font-weight: 600;
    }

    .asset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 0.75rem;
    }

    .asset-thumb {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      padding: 0.65rem;
      border-radius: 12px;
      background: rgba(108, 76, 255, 0.08);
      border: 2px solid transparent;
      transition: border 0.2s ease, background 0.2s ease;
    }

    .asset-thumb img {
      width: 100%;
      aspect-ratio: 1 / 1;
      object-fit: contain;
      background: rgba(0, 0, 0, 0.06);
      border-radius: 10px;
    }
    
    .asset-thumb img.asset-thumb-loading {
      opacity: 0.55;
      filter: saturate(0.4) blur(0.5px);
      transition: opacity 0.2s ease;
    }

    .asset-thumb-label {
      font-size: 0.8rem;
      text-align: center;
      word-break: break-all;
    }

    .asset-thumb.selected {
      border-color: var(--accent);
      background: rgba(108, 76, 255, 0.18);
    }

    body.dark .asset-thumb {
      background: rgba(108, 76, 255, 0.16);
    }

    body.dark .asset-thumb.selected {
      background: rgba(108, 76, 255, 0.28);
    }


    details.config-panel {
      border-radius: 12px;
      border: 1px solid rgba(31, 31, 31, 0.12);
      padding: 0.75rem 1rem;
      background: rgba(255, 255, 255, 0.6);
    }

    body.dark details.config-panel {
      border-color: rgba(245, 245, 247, 0.2);
      background: rgba(44, 44, 46, 0.55);
    }

    details.config-panel summary {
      font-weight: 600;
      cursor: pointer;
      outline: none;
    }

    details.config-panel[open] {
      box-shadow: inset 0 0 0 1px rgba(108, 76, 255, 0.25);
    }

    .flex-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .flex-row .field {
      flex: 1 1 160px;
    }

    .stage-indicator {
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(31, 31, 31, 0.6);
    }

    body.dark .stage-indicator {
      color: rgba(245, 245, 247, 0.6);
    }

    .stage-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.7);
    }

    body.dark .stage-content {
      background: rgba(44, 44, 46, 0.7);
    }

    .stage-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .stage-actions button {
      flex: 1 1 180px;
    }

    .timeline {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-height: 280px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .timeline-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.65);
      gap: 0.75rem;
    }

    body.dark .timeline-item {
      background: rgba(44, 44, 46, 0.65);
    }

    .timeline-item strong {
      display: block;
      font-size: 0.95rem;
    }

    .timeline-item span {
      font-size: 0.85rem;
      color: rgba(31, 31, 31, 0.65);
    }

    body.dark .timeline-item span {
      color: rgba(245, 245, 247, 0.65);
    }

    .log {
      font-size: 0.85rem;
      line-height: 1.4;
      white-space: pre-wrap;
      min-height: 2.5rem;
    }

    pre#quest-preview {
      background: rgba(0, 0, 0, 0.75);
      color: #f5f5f5;
      border-radius: 12px;
      padding: 1rem;
      max-height: 320px;
      overflow: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    footer {
      text-align: center;
      padding: 1.5rem;
      font-size: 0.85rem;
      color: rgba(31, 31, 31, 0.6);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
      }

      body:not(.light) {
        background: linear-gradient(135deg, rgba(108, 76, 255, 0.35), rgba(0, 199, 190, 0.35)), var(--bg-dark);
        color: #f5f5f7;
      }

      footer {
        color: rgba(245, 245, 247, 0.6);
      }
    }
</style>
<!-- ▼▼ 追加：トークン不要の Leaflet（OSM） ▼▼ -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- ▲▲ 追加ここまで ▲▲ -->
</head>
<body>
  <header>
    <h1>DramaBirthQuest Web Uploader</h1>
    <p>3DAdventureのクエストをウェブ上で設計し、Swiftアプリのクエスト作成画面と同じステップでシナリオを構築できます。<br>
      MapKitで配置したロケーション情報と合わせてアップロードまたはJSONとしてエクスポートしましょう。</p>
  </header>

  <main>
    <section class="card" aria-labelledby="mapkit-setup">
      <h2 id="mapkit-setup">MapKit 設定</h2>
      <p>このページにはMapKit JS用のJWTトークンがあらかじめ設定されています。「Mapを初期化」を押すだけで地図が読み込まれます。</p>
      <div class="button-row">
        <button class="primary" type="button" id="mapkit-init">Mapを初期化</button>
        <button class="secondary" type="button" id="toggle-theme">ライト/ダーク切替</button>
        <!-- ▼▼ 追加：トークン不要オプション ▼▼ -->
        <button class="flat" type="button" id="geo-get">現在地の座標</button>
        <button class="flat" type="button" id="fallback-map">代替マップで選択</button>
        <input id="place-or-url" type="text" placeholder="住所/地名 または Googleマップの共有URL" style="flex:1;min-width:220px;">
        <button class="flat" type="button" id="geocode-run">検索→座標</button>
        <!-- ▲▲ 追加ここまで ▲▲ -->
      </div>
      <div class="map-wrapper" role="region" aria-label="クエスト設置用マップ">
        <div id="map-main"></div>
      </div>
      <div class="flex-row">
        <div class="field">
          <label for="latitude">緯度 (Latitude)</label>
          <input id="latitude" type="number" step="any" placeholder="35.680959">
        </div>
        <div class="field">
          <label for="longitude">経度 (Longitude)</label>
          <input id="longitude" type="number" step="any" placeholder="139.767307">
        </div>
        <div class="field">
          <label for="regionRadius">表示範囲 (m)</label>
          <input id="regionRadius" type="number" min="100" value="500">
        </div>
      </div>
      <fieldset>
        <legend>配置モード</legend>
        <div class="flex-row">
          <label><input type="radio" name="location-mode" value="everywhere" checked> すべての場所</label>
          <label><input type="radio" name="location-mode" value="currentLocation"> 現在地を使用</label>
          <label><input type="radio" name="location-mode" value="specificLocation"> マップで指定</label>
        </div>
      </fieldset>
      <label for="location-name">場所名称 (任意)</label>
      <input id="location-name" type="text" placeholder="例: 渋谷駅ハチ公前">
      <label for="location-detail">場所の補足 (任意)</label>
      <input id="location-detail" type="text" placeholder="例: 待ち合わせ広場付近">
      <p class="log" id="map-log">マップが未初期化です。「Mapを初期化」を押してください。</p>
    </section>

    <section class="card" aria-labelledby="quest-settings">
      <h2 id="quest-settings">クエスト作成ウィザード</h2>
      <div class="stage-indicator" id="stage-indicator">STEP 1 / タイトルを決める</div>
      <div id="stage-container" class="stage-content" role="group" aria-live="polite"></div>

      <div>
        <h3 style="margin: 1rem 0 0.5rem; font-size: 1.05rem;">フロー (アプリ下部タイムラインと同等)</h3>
        <div id="timeline" class="timeline" role="list"></div>
      </div>

      <label for="quest-preview">JSONプレビュー</label>
      <pre id="quest-preview" aria-live="polite">{
  "title": "",
  "bgType": "",
  "bgURL": "",
  "dialogLines": [],
  "flowOps": [],
  "assets": {},
  "location": {
    "mode": "everywhere",
    "latitude": null,
    "longitude": null,
    "radius": 500
  }
}</pre>
    </section>

    <section class="card" aria-labelledby="upload-section">
      <h2 id="upload-section">アップロード &amp; エクスポート</h2>
      <p>アップロードボタンを押すと Firebase（プロジェクト: <code>poketquest-3a73d</code>）に直接保存され、iOSアプリと同じ形式でクエストが追加されます。MapKit の地点指定を行わなくても、位置情報フィールドはアプリで利用できる値が保存されます。</p>
      <p class="log" id="firebase-status">Firebaseの初期化を待機しています…</p>
      
      <div class="auth-panel" role="group" aria-live="polite">
        <p class="log" id="auth-status">Googleアカウントでサインインしていません。</p>
        <div class="auth-actions">
          <button class="primary" type="button" id="google-sign-in">Googleでログイン</button>
          <button class="secondary" type="button" id="google-switch" disabled>別のGoogleアカウントに切り替え</button>
          <button class="flat" type="button" id="google-sign-out" disabled>ログアウト</button>
        </div>
      </div>


      <details class="config-panel">
        <summary>Firebase設定（Web APIキーを貼り付け）</summary>
        <p>Firebaseコンソール &gt; プロジェクトの設定 &gt; 「アプリを追加」で Web アプリを登録し、表示される構成スニペットを JSON 形式で貼り付けてください。保存するとブラウザに暗号化せず保持されるため、共有端末では使用後に削除してください。</p>
        <label for="firebase-config-input">Firebase構成 JSON</label>
        <textarea id="firebase-config-input" rows="6" placeholder='{"apiKey":"AIza...","authDomain":"example.firebaseapp.com","projectId":"example","storageBucket":"example.appspot.com","messagingSenderId":"","appId":""}'></textarea>
        <div class="button-row">
          <button class="flat" type="button" id="save-firebase-config">保存</button>
          <button class="flat" type="button" id="clear-firebase-config">保存した設定を削除</button>
          <button class="flat" type="button" id="test-firebase-config">接続を再試行</button>
        </div>
        <p class="log" id="firebase-config-log">Web用の Firebase 構成が設定されていない場合、Googleサインインを実行できません。</p>
      </details>
      <div class="button-row">
        <button class="primary" type="button" id="upload-quest">アップロード</button>
        <button class="secondary" type="button" id="download-quest">JSONをダウンロード</button>
        <button class="danger" type="button" id="reset-all">すべてリセット</button>
      </div>

      <p class="log" id="upload-log">Googleでサインインし、必要な項目を入力したら「アップロード」を押してください。</p>
    </section>
  </main>

  <footer>
    3DAdventure Quest Builder &copy; 2025 — Swift版のロジックに合わせたステージ進行とJSONスキーマを採用しています。
  </footer>

  <script>
    const stageContainer = document.getElementById('stage-container');
    const stageIndicator = document.getElementById('stage-indicator');
    const timelineContainer = document.getElementById('timeline');
    const questPreview = document.getElementById('quest-preview');
    const mapLog = document.getElementById('map-log');
    const uploadLog = document.getElementById('upload-log');
    const firebaseStatus = document.getElementById('firebase-status');
    const firebaseConfigInput = document.getElementById('firebase-config-input');
    const firebaseConfigLog = document.getElementById('firebase-config-log');
    const firebaseConfigSaveButton = document.getElementById('save-firebase-config');
    const firebaseConfigClearButton = document.getElementById('clear-firebase-config');
    const firebaseConfigTestButton = document.getElementById('test-firebase-config');
    const authStatus = document.getElementById('auth-status');
    const googleSignInButton = document.getElementById('google-sign-in');
    const googleSwitchButton = document.getElementById('google-switch');
    const googleSignOutButton = document.getElementById('google-sign-out');
    
    const latitudeInput = document.getElementById('latitude');
    const longitudeInput = document.getElementById('longitude');
    const radiusInput = document.getElementById('regionRadius');
    const locationModeInputs = Array.from(document.querySelectorAll('input[name="location-mode"]'));
    const locationNameInput = document.getElementById('location-name');
    const locationDetailInput = document.getElementById('location-detail');

    const geoGetBtn = document.getElementById('geo-get');
    const fallbackMapBtn = document.getElementById('fallback-map');
    const placeOrUrlInput = document.getElementById('place-or-url');
    const geocodeRunBtn = document.getElementById('geocode-run');


    async function ensureMapKitInitialized() {
      if (typeof mapkit === 'undefined') {
        mapLog.textContent = 'MapKit JSが読み込まれていません。ネットワーク接続やスクリプトURLを確認してください。';
        return false;
      }

      if (!window.__mapkitInited) {
        mapkit.init({
          authorizationCallback: async done => {
            try {
              const token = await fetch('https://mapkit-token-api.vercel.app/api/mapkit-token', {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
                mode: 'cors'
              }).then(r => r.text());
              done(token);
            } catch (error) {
              console.error('Failed to fetch MapKit token', error);
              mapLog.textContent = 'MapKitトークンの取得に失敗しました。しばらくしてから再試行してください。';
              done('');
            }
          }
        });
        window.__mapkitInited = true;
      }

      return true;
    }


    function setLatLng(lat, lng, note = '') {
      const latNum = Number(lat), lngNum = Number(lng);
      if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) {
        alert('座標が不正です');
        return;
      }
      latitudeInput.value = latNum.toFixed(6);
      longitudeInput.value = lngNum.toFixed(6);


      state.selectedCoordinate = { latitude: latNum, longitude: lngNum };
      const modeRadio = document.querySelector('input[name="location-mode"][value="specificLocation"]');
      if (modeRadio) modeRadio.checked = true;
      state.locationChoice.mode = 'specificLocation';

      mapLog.textContent = `座標を設定: ${latNum.toFixed(6)}, ${lngNum.toFixed(6)}${note ? '（' + note + '）' : ''}`;


      if (window.__leafletMap && window.__leafletMarker) {
        window.__leafletMarker.setLatLng([latNum, lngNum]).addTo(window.__leafletMap);
        window.__leafletMap.setView([latNum, lngNum], 16);
      }

      renderQuestPreview();
    }

    function getBrowserGeolocation() {
      if (!('geolocation' in navigator)) {
        alert('このブラウザは現在地取得に対応していません');
        return;
      }
      mapLog.textContent = '現在地の取得を要求しています…（ブラウザの許可が必要です）';
      navigator.geolocation.getCurrentPosition(
        pos => {
          const { latitude, longitude } = pos.coords;
          setLatLng(latitude, longitude, '現在地');
        },
        err => {
          mapLog.textContent = `現在地の取得に失敗: ${err.message}`;
          alert('現在地の取得に失敗しました。位置情報の権限や設定をご確認ください。');
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
      );
    }

    function tryParseGoogleMapsURL(input) {
      try {
        const url = new URL(input);

        const at = url.href.match(/@(-?\d+\.\d+),(-?\d+\.\d+)/);
        if (at) return { lat: parseFloat(at[1]), lng: parseFloat(at[2]) };

        const q = url.searchParams.get('q') || url.searchParams.get('query');
        if (q) {
          const m = q.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
          if (m) return { lat: parseFloat(m[1]), lng: parseFloat(m[2]) };
        }

      } catch (_) {
        /* 入力がURLでない場合は無視 */
      }
      return null;
    }


    async function geocodeWithNominatim(query) {
      const endpoint = 'https://nominatim.openstreetmap.org/search';
      const url = `${endpoint}?format=jsonv2&limit=1&q=${encodeURIComponent(query)}`;
      const res = await fetch(url, {
        headers: { 'Accept-Language': 'ja' }
      });
      if (!res.ok) throw new Error(`Geocoding failed: ${res.status}`);
      const json = await res.json();
      if (!Array.isArray(json) || json.length === 0) return null;
      const hit = json[0];
      return { lat: parseFloat(hit.lat), lng: parseFloat(hit.lon), displayName: hit.display_name };
    }

    function initTokenlessMap() {
      if (!window.L) {
        alert('Leaflet の読み込みに失敗しました（ネットワークをご確認ください）');
        return;
      }

      const container = document.getElementById('map-main');
      if (!container) return;


      if (window.__leafletMap) {
        mapLog.textContent = '代替マップを表示中です。マップをクリックすると座標が入ります。';
        return;
      }


      const initLat = parseFloat(latitudeInput.value) || 35.681236;
      const initLng = parseFloat(longitudeInput.value) || 139.767125;


      container.innerHTML = '';

      const map = L.map(container, { zoomControl: true }).setView([initLat, initLng], 14);
      L.tileLayer(
        'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        { attribution: '&copy; OpenStreetMap contributors' }
      ).addTo(map);

      const marker = L.marker([initLat, initLng], { draggable: true }).addTo(map);
      marker.on('dragend', () => {
        const ll = marker.getLatLng();
        setLatLng(ll.lat, ll.lng, 'ドラッグ');
      });

      map.on('click', (e) => {
        marker.setLatLng(e.latlng);
        setLatLng(e.latlng.lat, e.latlng.lng, 'クリック');
      });

      window.__leafletMap = map;
      window.__leafletMarker = marker;

      mapLog.textContent = '代替マップを表示しました。マップをクリック/ドラッグで座標を設定できます。';
    }


    const state = {
      map: null,
      mapkitInitialized: false,
      marker: null,
      selectedCoordinate: null,
      stage: 'askTitle',
      title: '',
      authorUID: 'guest',
      background: { type: '', youtubeId: '', assetKey: null, assetURL: '', libraryPath: null },
      flowOps: [],
      assets: {},
      cover: { assetKey: null, url: '' },
      allowFinishOptions: false,
      textDraft: { type: 'text', narration: false, speaker: 'center', text: '' },
      charDraft: {},
      pendingBackgroundChange: null,
      tempSlot: null,
      locationChoice: { mode: 'everywhere', name: '', detail: '' },
      libraries: {
        characters: {
          loading: false,
          loaded: false,
          error: '',
          items: [],
          promise: null
          },
        backgrounds: {
          loading: false,
          loaded: false,
          error: '',
          items: [],
          promise: null
        }
      }
    };
    
    let isTitleComposing = false;

    const FIREBASE_CONFIG_STORAGE_KEY = 'dbq-firebase-config';

    let firebaseApp = null;
    let firebaseAuth = null;
    let firebaseFirestore = null;
    let firebaseStorage = null;
    let firebaseInitError = null;
    let firebaseUserDisplayName = '';
    let authProcessing = false;
    let authErrorMessage = '';
    let lastSignedInUid = null;
    let firebaseConfig = loadStoredFirebaseConfig();

    const DEFAULT_FIREBASE_CONFIG = {
      apiKey: 'AIzaSyA7E1JxNHPcnl6Uw4PhQjQ9nxJ3JneA2ac',
      authDomain: 'poketquest-3a73d.firebaseapp.com',
      projectId: 'poketquest-3a73d',
      storageBucket: 'poketquest-3a73d.firebasestorage.app',
      messagingSenderId: '254784688722',
      appId: '1:254784688722:web:d3d6a4ba47c089b4c8058b',
      measurementId: 'G-4DD1TP561H'
    };

    function loadStoredFirebaseConfig() {
      if (!('localStorage' in window)) return null;
      try {
        const raw = window.localStorage.getItem(FIREBASE_CONFIG_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
          return parsed;
        }
      } catch (error) {
        console.warn('Failed to read stored Firebase config', error);
      }
      return null;
    }

    function saveFirebaseConfig(config) {
      if (!('localStorage' in window)) return;
      try {
        window.localStorage.setItem(FIREBASE_CONFIG_STORAGE_KEY, JSON.stringify(config));
        firebaseConfig = config;
      } catch (error) {
        console.warn('Failed to save Firebase config', error);
        firebaseConfig = config;
      }
    }

    function clearStoredFirebaseConfig() {
      if (!('localStorage' in window)) return;
      try {
        window.localStorage.removeItem(FIREBASE_CONFIG_STORAGE_KEY);
      } catch (error) {
        console.warn('Failed to clear Firebase config', error);
      }
      firebaseConfig = null;
    }

    function validateFirebaseConfig(config) {
      if (!config || typeof config !== 'object') {
        return 'JSONがオブジェクト形式ではありません。';
      }
      const requiredFields = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'appId'];
      for (const field of requiredFields) {
        if (typeof config[field] !== 'string' || !config[field]) {
          return `必須フィールド「${field}」が見つからないか空です。`;
        }
      }
      return null;
    }

    function updateFirebaseConfigEditor() {
      if (!firebaseConfigInput || !firebaseConfigLog) return;
      if (firebaseConfig) {
        firebaseConfigInput.value = JSON.stringify(firebaseConfig, null, 2);
        firebaseConfigLog.textContent = 'Web用のFirebase構成を保存しています。この設定で接続を試みます。';
      } else {
        firebaseConfigInput.value = '';
        firebaseConfigLog.textContent = 'Web用の構成が未保存のため、iOSアプリ用のデフォルト設定で接続を試みます（制限されている場合はエラーになります）。';
      }
    }

    function usingDefaultFirebaseConfig() {
      return !firebaseConfig;
    }

    function getActiveFirebaseConfig() {
      return firebaseConfig || DEFAULT_FIREBASE_CONFIG;
    }

    async function resetFirebaseState() {
      if (firebaseApp && typeof firebaseApp.delete === 'function') {
        try {
          await firebaseApp.delete();
        } catch (error) {
          console.warn('Failed to delete Firebase app before reinitializing', error);
        }
      }
      firebaseApp = null;
      firebaseAuth = null;
      firebaseFirestore = null;
      firebaseStorage = null;
      firebaseInitError = null;
      firebaseUserDisplayName = '';
      authProcessing = false;
      authErrorMessage = '';
      lastSignedInUid = null;
      updateAuthUI();
    }

    async function reinitializeFirebase() {
      await resetFirebaseState();
      initializeFirebase();
    }

    function adminRestrictedGuidance() {
      return 'Firebaseコンソールで Web アプリを作成し、そこで発行された Web APIキーと構成をこのページの「Firebase設定」に保存してください。あわせて「Authentication &gt; サインイン方法」で Google プロバイダが有効になっているか確認してください。';
    }
    function setStage(next) {
      state.stage = next;
      renderStage();
    }

    function generateStageLabel(stage) {
      switch (stage) {
        case 'askTitle':
          return 'STEP 1 / タイトルを決める';
        case 'askBackground':
          return 'STEP 2 / 初期背景を選ぶ';
        case 'menu':
          return 'STEP 3 / 次のアクションを選択';
        case 'addCharacter':
          return 'キャラクターを登場させる';
        case 'removeCharacter':
          return 'キャラクターを退場させる';
        case 'changeCharMotionTarget':
          return '動きを変える対象を選ぶ';
        case 'chooseCharAnim':
          return 'キャラの動きを決める';
        case 'chooseTextType':
          return '文章の種類を選ぶ';
        case 'chooseTextSpeaker':
          return '話者を決める';
        case 'addText':
          return 'セリフ / ナレーションを入力';
        case 'addWait':
          return '何もしない時間を追加';
        case 'changeBG':
          return '背景を変更する';
        case 'chooseTransition':
          return '背景トランジションを選ぶ';
        case 'chooseCover':
          return 'トップ画像を設定';
        case 'askThumbnail':
          return '仕上げと確認';
        default:
          return 'クエスト作成';
      }
    }

    function renderStage() {
      const activeElement = document.activeElement;
      const shouldRestoreFocus = activeElement && stageContainer.contains(activeElement);
      const previousFocusId = shouldRestoreFocus ? activeElement.id : null;
      const previousSelection = shouldRestoreFocus && 'selectionStart' in activeElement
        ? { start: activeElement.selectionStart, end: activeElement.selectionEnd }
        : null;

      stageIndicator.textContent = generateStageLabel(state.stage);
      stageContainer.innerHTML = '';
      switch (state.stage) {
        case 'askTitle':
          renderAskTitle();
          break;
        case 'askBackground':
          renderAskBackground();
          break;
        case 'menu':
          renderMenu();
          break;
        case 'addCharacter':
          renderAddCharacter();
          break;
        case 'removeCharacter':
          renderRemoveCharacter();
          break;
        case 'changeCharMotionTarget':
          renderChangeCharMotionTarget();
          break;
        case 'chooseCharAnim':
          renderChooseCharAnim();
          break;
        case 'chooseTextType':
          renderChooseTextType();
          break;
        case 'chooseTextSpeaker':
          renderChooseTextSpeaker();
          break;
        case 'addText':
          renderAddText();
          break;
        case 'addWait':
          renderAddWait();
          break;
        case 'changeBG':
          renderChangeBackground();
          break;
        case 'chooseTransition':
          renderChooseTransition();
          break;
        case 'chooseCover':
          renderChooseCover();
          break;
        case 'askThumbnail':
          renderAskThumbnail();
          break;
        default:
          stageContainer.textContent = '未定義のステージです。';
      }
      renderTimeline();
      renderQuestPreview();
      
      if (previousFocusId) {
        const nextFocusTarget = document.getElementById(previousFocusId);
        if (nextFocusTarget && typeof nextFocusTarget.focus === 'function') {
          nextFocusTarget.focus({ preventScroll: true });
          if (previousSelection && typeof nextFocusTarget.setSelectionRange === 'function') {
            nextFocusTarget.setSelectionRange(previousSelection.start, previousSelection.end);
          }
        }
      }
    }

    function createElement(tag, options = {}) {
      const el = document.createElement(tag);
      if (options.className) el.className = options.className;
      if (options.textContent !== undefined) el.textContent = options.textContent;
      if (options.innerHTML !== undefined) el.innerHTML = options.innerHTML;
      if (options.type) el.type = options.type;
      if (options.value !== undefined) el.value = options.value;
      if (options.placeholder !== undefined) el.placeholder = options.placeholder;
      if (options.min !== undefined) el.min = options.min;
      if (options.max !== undefined) el.max = options.max;
      if (options.step !== undefined) el.step = options.step;
      if (options.checked !== undefined) el.checked = options.checked;
      if (options.disabled !== undefined) el.disabled = options.disabled;
      if (options.htmlFor) el.htmlFor = options.htmlFor;
      if (options.multiple !== undefined) el.multiple = options.multiple;
      if (options.accept !== undefined) el.accept = options.accept;
      if (options.id) el.id = options.id;
      return el;
    }

    function renderAskTitle() {
      const titleLabel = createElement('label', { htmlFor: 'quest-title-input', textContent: 'クエストタイトル' });
      const titleInput = createElement('input', { type: 'text', id: 'quest-title-input', value: state.title, placeholder: '例: 失われた記憶のかけら' });
      let nextButton;
      const updateNextButtonState = () => {
        if (nextButton) {
          nextButton.disabled = !state.title.trim();
        }
      };
      titleInput.addEventListener('compositionstart', () => {
        isTitleComposing = true;
      });
      titleInput.addEventListener('compositionend', () => {
        isTitleComposing = false;
        state.title = titleInput.value;
        renderQuestPreview();
        updateNextButtonState();
      });
      titleInput.addEventListener('input', () => {
        state.title = titleInput.value;
        renderQuestPreview();
        updateNextButtonState();
      });
      titleInput.addEventListener('keydown', event => {
        if (event.key === 'Enter' && !event.isComposing && !isTitleComposing) {
          event.preventDefault();
          updateNextButtonState();
          if (!nextButton?.disabled) {
            setStage('askBackground');
          }
        }
      });

      const authorLabel = createElement('label', { htmlFor: 'quest-author-input', textContent: '作者UID (未ログインの場合は guest)' });
      const authorInput = createElement('input', { type: 'text', id: 'quest-author-input', value: state.authorUID, placeholder: 'guest' });
      authorInput.addEventListener('input', () => {
        state.authorUID = authorInput.value.trim() || 'guest';
        renderQuestPreview();
      });

      const actions = createElement('div', { className: 'stage-actions' });
      nextButton = createElement('button', { className: 'primary', type: 'button', textContent: '次へ（背景を決める）' });
      updateNextButtonState();
      nextButton.addEventListener('click', () => setStage('askBackground'));
      actions.appendChild(nextButton);

      stageContainer.append(titleLabel, titleInput, authorLabel, authorInput, actions);
    }
    function renderAskBackground() {
      const info = createElement('p', { textContent: 'アプリと同様に、最初に表示する背景を選択します。YouTube動画か画像のどちらかを指定してください。' });
      const typeLabel = createElement('label', { textContent: '背景タイプ' });
      const typeSelect = createElement('select');
      ['', 'youtube', 'image'].forEach(value => {
        const option = createElement('option', { value, textContent: value === '' ? '選択してください' : (value === 'youtube' ? 'YouTube' : '画像') });
        if (state.background.type === value) option.selected = true;
        typeSelect.appendChild(option);
      });

      const youtubeLabel = createElement('label', { htmlFor: 'bg-youtube-input', textContent: 'YouTubeリンクまたはID' });
      const youtubeInput = createElement('input', { type: 'text', id: 'bg-youtube-input', value: state.background.youtubeId, placeholder: 'https://youtu.be/...' });
      youtubeLabel.style.display = youtubeInput.style.display = state.background.type === 'youtube' ? 'block' : 'none';

      const imageLabel = createElement('label', { htmlFor: 'bg-image-input', textContent: '背景画像 (アップロード)' });
      const imageInput = createElement('input', { type: 'file', id: 'bg-image-input', accept: 'image/*' });
      const showImageControls = state.background.type === 'image';
      imageLabel.style.display = imageInput.style.display = showImageControls ? 'block' : 'none';

      let libraryContainer = null;
      if (state.background.type === 'image') {
        libraryContainer = createElement('div', { className: 'asset-library' });

        const renderLibrary = () => {
          const libraryState = state.libraries.backgrounds;
          libraryContainer.innerHTML = '';

          const header = createElement('div', { className: 'asset-library-header' });
          const title = createElement('span', {
            className: 'asset-library-header-title',
            textContent: 'アップロード済みの背景画像'
          });
          header.appendChild(title);

          const refreshButton = createElement('button', {
            className: 'flat',
            type: 'button',
            textContent: libraryState.loading ? '読み込み中…' : '再読み込み'
          });
          refreshButton.disabled = libraryState.loading;
          refreshButton.addEventListener('click', async () => {
            try {
              await loadBackgroundLibrary(true);
            } catch (error) {
              console.error('Failed to refresh background library', error);
            } finally {
              if (state.stage === 'askBackground' && state.background.type === 'image') {
                renderStage();
              }
            }
          });
          header.appendChild(refreshButton);
          libraryContainer.appendChild(header);

          if (libraryState.error) {
            const errorMessage = createElement('p', { className: 'log', textContent: `読み込みエラー: ${libraryState.error}` });
            libraryContainer.appendChild(errorMessage);
            return;
          }

          if (libraryState.loading && libraryState.items.length === 0) {
            const loadingMessage = createElement('p', { className: 'log', textContent: '背景画像を読み込み中です…' });
            libraryContainer.appendChild(loadingMessage);
            return;
          }

          if (libraryState.items.length === 0) {
            const emptyMessage = createElement('p', { className: 'log', textContent: 'まだ利用可能な背景画像がありません。' });
            libraryContainer.appendChild(emptyMessage);
            return;
          }

          const grid = createElement('div', { className: 'asset-grid' });
          libraryState.items.forEach(item => {
            const button = createElement('button', { className: 'asset-thumb', type: 'button' });
            if (
              state.background.libraryPath === item.fullPath ||
              (!state.background.libraryPath && state.background.assetURL === item.url)
            ) {
              button.classList.add('selected');
            }
            const image = document.createElement('img');
            applyLibraryThumbnail(image, item);
            const label = createElement('span', { className: 'asset-thumb-label', textContent: item.name });
            button.append(image, label);
            button.addEventListener('click', () => {
              state.background.assetKey = null;
              state.background.assetURL = item.url;
              state.background.libraryPath = item.fullPath;
              renderQuestPreview();
              renderStage();
            });
            grid.appendChild(button);
          });
          libraryContainer.appendChild(grid);
        };

        renderLibrary();

        if (!state.libraries.backgrounds.loaded && !state.libraries.backgrounds.loading) {
          loadBackgroundLibrary()
            .then(() => {
              if (state.stage === 'askBackground' && state.background.type === 'image') {
                renderStage();
              }
            })
            .catch(error => {
              console.error('Failed to load background library', error);
              if (state.stage === 'askBackground' && state.background.type === 'image') {
                renderStage();
              }
            });
        }
      }

      let nextButton;

      typeSelect.addEventListener('change', () => {
        state.background.type = typeSelect.value;
        if (typeSelect.value !== 'youtube') state.background.youtubeId = '';
        if (typeSelect.value !== 'image') {
          state.background.assetKey = null;
          state.background.assetURL = '';
          state.background.libraryPath = null;
        }
        renderStage();
      });

      youtubeInput.addEventListener('input', () => {
        state.background.youtubeId = youtubeInput.value.trim();
        renderQuestPreview();
        if (nextButton) {
          nextButton.disabled = !isBackgroundReady(state.background);
        }
      });

      imageInput.addEventListener('change', async () => {
        const file = imageInput.files?.[0];
        if (!file) return;
        const dataUrl = await fileToDataURL(file);
        const key = storeAsset(dataUrl, 'background', file.name);
        state.background.assetKey = key;
        state.background.assetURL = '';
        state.background.libraryPath = null;
        renderQuestPreview();
        renderStage();
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
      backButton.addEventListener('click', () => setStage('askTitle'));
      nextButton = createElement('button', { className: 'primary', type: 'button', textContent: '次へ（メニューへ）' });
      nextButton.disabled = !isBackgroundReady(state.background);
      nextButton.addEventListener('click', () => setStage('menu'));

      actions.append(backButton, nextButton);

      const currentStatus = createElement('p', {
        className: 'log',
        textContent: state.background.type === 'image'
          ? (state.background.assetKey
              ? `選択済み: asset://${state.background.assetKey}`
              : (state.background.assetURL
                ? `選択済み: ${state.background.libraryPath || state.background.assetURL}`
                : '背景画像が未選択です。'))
          : 'YouTubeリンクを指定してください。'
      });

      const children = [info, typeLabel, typeSelect, youtubeLabel, youtubeInput, imageLabel, imageInput];
      if (libraryContainer) {
        children.push(libraryContainer);
      }
      if (state.background.type === 'image') {
        children.push(currentStatus);
      }
      children.push(actions);

      stageContainer.append(...children);
    }

    function isBackgroundReady(bg) {
      if (bg.type === 'youtube') {
        return !!extractYouTubeID(bg.youtubeId);
      }
      if (bg.type === 'image') {
        return !!bg.assetKey || !!bg.assetURL;
      }
      return false;
    }

    function renderMenu() {
      state.allowFinishOptions = state.flowOps.length > 0;
      const info = createElement('p', { textContent: 'Swiftアプリのメニューと同じ選択肢です。追加したい操作を選んでください。' });
      const actions = createElement('div', { className: 'stage-actions' });

      const addCharButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラクターを登場させる' });
      addCharButton.addEventListener('click', () => setStage('addCharacter'));
      actions.appendChild(addCharButton);

      const activeSlots = getActiveSlots();
      if (activeSlots.size > 0) {
        const removeButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラクターを消す' });
        removeButton.addEventListener('click', () => setStage('removeCharacter'));
        actions.appendChild(removeButton);

        const changeMotionButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラクターの動きを変える / 向きを変える' });
        changeMotionButton.addEventListener('click', () => setStage('changeCharMotionTarget'));
        actions.appendChild(changeMotionButton);
      }

      const textButton = createElement('button', { className: 'flat', type: 'button', textContent: '文章を入れる' });
      textButton.addEventListener('click', () => setStage('chooseTextType'));
      actions.appendChild(textButton);

      const waitButton = createElement('button', { className: 'flat', type: 'button', textContent: '少し待つ（ウェイト）' });
      waitButton.addEventListener('click', () => setStage('addWait'));
      actions.appendChild(waitButton);

      const bgButton = createElement('button', { className: 'flat', type: 'button', textContent: '背景を変える' });
      bgButton.addEventListener('click', () => {
        state.pendingBackgroundChange = { type: '', youtubeId: '', assetKey: null, assetURL: '', libraryPath: null };
        setStage('changeBG');
      });
      actions.appendChild(bgButton);

      const coverButton = createElement('button', { className: 'flat', type: 'button', textContent: 'トップ画像（サムネ）を選ぶ' });
      coverButton.addEventListener('click', () => setStage('chooseCover'));
      actions.appendChild(coverButton);

      if (state.allowFinishOptions) {
        const finishButton = createElement('button', { className: 'primary', type: 'button', textContent: 'これで終わり（仕上げへ）' });
        finishButton.addEventListener('click', () => setStage('askThumbnail'));
        actions.appendChild(finishButton);
      }

      const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '背景をやり直す' });
      backButton.addEventListener('click', () => setStage('askBackground'));
      actions.appendChild(backButton);

      stageContainer.append(info, actions);
    }
    function renderAddCharacter() {
      const info = createElement('p', { textContent: '登場させたいキャラクターの画像と配置、動きを設定します。' });

      const sourceLabel = createElement('label', { textContent: '画像の指定方法' });
      const sourceSelect = createElement('select');
      if (state.charDraft.source === 'url') {
        state.charDraft.source = 'library';
      }
      const allowedSources = new Set(['upload', 'library']);
      if (!state.charDraft.source || !allowedSources.has(state.charDraft.source)) {
        state.charDraft.source = 'upload';
      }
      [['upload', '画像をアップロード'], ['library', 'アップロード済みから選択']].forEach(([value, label]) => {
        const option = createElement('option', { value, textContent: label });
        if (state.charDraft.source === value) option.selected = true;
        sourceSelect.appendChild(option);
      });

      const fileLabel = createElement('label', { htmlFor: 'char-image-file', textContent: 'キャラクター画像' });
      const fileInput = createElement('input', { type: 'file', id: 'char-image-file', accept: 'image/*' });
      const useUpload = sourceSelect.value === 'upload';
      fileLabel.style.display = useUpload ? 'block' : 'none';
      fileInput.style.display = useUpload ? 'block' : 'none';

      let libraryContainer = null;
      if (sourceSelect.value === 'library') {
        libraryContainer = createElement('div', { className: 'asset-library' });

        const renderLibrary = () => {
          const libraryState = state.libraries.characters;
          libraryContainer.innerHTML = '';

          const header = createElement('div', { className: 'asset-library-header' });
          const title = createElement('span', { className: 'asset-library-header-title', textContent: 'アップロード済みのキャラクター画像' });
          header.appendChild(title);

          const refreshButton = createElement('button', {
            className: 'flat',
            type: 'button',
            textContent: libraryState.loading ? '読み込み中…' : '再読み込み'
          });
          refreshButton.disabled = libraryState.loading;
          refreshButton.addEventListener('click', async () => {
            try {
              await loadCharacterLibrary(true);
            } catch (error) {
              console.error('Failed to refresh character library', error);
            } finally {
              if (state.stage === 'addCharacter' && (state.charDraft.source || 'upload') === 'library') {
                renderStage();
              }
            }
          });
          header.appendChild(refreshButton);
          libraryContainer.appendChild(header);

          if (libraryState.error) {
            const errorMessage = createElement('p', { className: 'log', textContent: `読み込みエラー: ${libraryState.error}` });
            libraryContainer.appendChild(errorMessage);
            return;
          }

          if (libraryState.loading && libraryState.items.length === 0) {
            const loadingMessage = createElement('p', { className: 'log', textContent: 'キャラクター画像を読み込み中です…' });
            libraryContainer.appendChild(loadingMessage);
            return;
          }

          if (libraryState.items.length === 0) {
            const emptyMessage = createElement('p', { className: 'log', textContent: 'まだ利用可能なキャラクター画像がありません。' });
            libraryContainer.appendChild(emptyMessage);
            return;
          }

          const grid = createElement('div', { className: 'asset-grid' });
          libraryState.items.forEach(item => {
            const button = createElement('button', { className: 'asset-thumb', type: 'button' });
            if (state.charDraft.libraryPath === item.fullPath || (!state.charDraft.libraryPath && state.charDraft.assetURL === item.url)) {
              button.classList.add('selected');
            }
            const image = document.createElement('img');
            applyLibraryThumbnail(image, item);
            const label = createElement('span', { className: 'asset-thumb-label', textContent: item.name });
            button.append(image, label);
            button.addEventListener('click', () => {
              state.charDraft.assetKey = null;
              state.charDraft.assetURL = item.url;
              state.charDraft.libraryPath = item.fullPath;
              state.charDraft.source = 'library';
              renderStage();
            });
            grid.appendChild(button);
          });
          libraryContainer.appendChild(grid);
        };

        renderLibrary();

        if (!state.libraries.characters.loaded && !state.libraries.characters.loading) {
          loadCharacterLibrary().then(() => {
            if (state.stage === 'addCharacter' && (state.charDraft.source || 'upload') === 'library') {
              renderStage();
            }
          }).catch(error => {
            console.error('Failed to load character library', error);
            if (state.stage === 'addCharacter' && (state.charDraft.source || 'upload') === 'library') {
              renderStage();
            }
          });
        }
      }

      const positionLabel = createElement('label', { textContent: '配置位置' });
      const positionSelect = createElement('select');
      const occupied = getActiveSlots();
      [['left', '左'], ['center', '真ん中'], ['right', '右']].forEach(([value, label]) => {
        const option = createElement('option', { value, textContent: label });
        option.disabled = occupied.has(value);
        if (!option.disabled && !state.charDraft.slot) {
          state.charDraft.slot = value;
          option.selected = true;
        }
        if (state.charDraft.slot === value) option.selected = true;
        positionSelect.appendChild(option);
      });

      const scaleLabel = createElement('label', { htmlFor: 'char-scale', textContent: '表示倍率 (0.5〜2.0)' });
      const scaleInput = createElement('input', { type: 'number', id: 'char-scale', min: 0.5, max: 2, step: 0.1, value: state.charDraft.scale || 1.0 });

      const animLabel = createElement('label', { textContent: '初期モーション' });
      const animSelect = createElement('select');
      [['none', '動かない'], ['upDown', '浮いている'], ['shake', '左右に揺れる'], ['hop', 'ジャンプしている']].forEach(([value, label]) => {
        const option = createElement('option', { value, textContent: label });
        if ((state.charDraft.anim || 'none') === value) option.selected = true;
        animSelect.appendChild(option);
      });

      sourceSelect.addEventListener('change', () => {
        state.charDraft.source = sourceSelect.value;
        if (state.charDraft.source === 'library') {
          state.charDraft.assetKey = null;
        } else if (state.charDraft.source === 'upload') {
          state.charDraft.libraryPath = null;
        }
        renderStage();
      });


      positionSelect.addEventListener('change', () => {
        state.charDraft.slot = positionSelect.value;
      });

      scaleInput.addEventListener('input', () => {
        const val = parseFloat(scaleInput.value);
        if (Number.isFinite(val)) {
          state.charDraft.scale = val;
        }
      });

      animSelect.addEventListener('change', () => {
        state.charDraft.anim = animSelect.value;
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.charDraft = {};
        setStage('menu');
      });

      const addButton = createElement('button', { className: 'primary', type: 'button', textContent: 'キャラクターを追加' });
      addButton.addEventListener('click', async () => {
        try {
          if (!state.charDraft.slot) {
            alert('配置できる位置がありません。');
            return;
          }
          let assetKey = null;
          let assetURL = '';
          const source = state.charDraft.source || 'upload';
          if (source === 'upload') {
            const file = fileInput.files?.[0];
            if (!file) {
              alert('キャラクター画像を選択してください。');
              return;
            }
            const dataUrl = await fileToDataURL(file);
            assetKey = storeAsset(dataUrl, 'character', file.name);
          } else if (source === 'library') {
            const selected = (state.charDraft.assetURL || '').trim();
            if (!selected) {
              alert('アップロード済みのキャラクター画像を選択してください。');
              return;
            }
            assetURL = selected;
            assetKey = null;
          } else {
            alert('キャラクター画像の指定方法を選択してください。');
            return;
          }

          const op = {
            kind: 'charAdd',
            slot: state.charDraft.slot,
            anim: state.charDraft.anim || 'none',
            scale: Number(state.charDraft.scale || 1.0),
            assetKey,
            assetURL
          };
          appendFlowOp(op);
          state.charDraft = {};
          setStage('menu');
        } catch (error) {
          console.error(error);
          alert('画像の読み込みに失敗しました。');
        }
      });

      actions.append(cancelButton, addButton);

      const children = [info, sourceLabel, sourceSelect, fileLabel, fileInput];
      if (libraryContainer) {
        children.push(libraryContainer);
      }
      children.push(positionLabel, positionSelect, scaleLabel, scaleInput, animLabel, animSelect, actions);
      stageContainer.append(...children);
    }

    function renderRemoveCharacter() {
      const info = createElement('p', { textContent: '退場させたいキャラクターの位置を選択してください。' });
      const slots = Array.from(getActiveSlots());
      if (slots.length === 0) {
        const warn = createElement('p', { textContent: '現在舞台にキャラクターはいません。', className: 'log' });
        const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
        backButton.addEventListener('click', () => setStage('menu'));
        stageContainer.append(info, warn, backButton);
        return;
      }

      const actions = createElement('div', { className: 'stage-actions' });
      slots.forEach(slot => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: slotLabel(slot) });
        btn.addEventListener('click', () => {
          appendFlowOp({ kind: 'charRemove', slot });
          setStage('menu');
        });
        actions.appendChild(btn);
      });

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }

    function renderChangeCharMotionTarget() {
      const info = createElement('p', { textContent: '動きを変えたいキャラクターを選択してください。' });
      const slots = Array.from(getActiveSlots());
      if (slots.length === 0) {
        const warn = createElement('p', { textContent: '現在舞台にキャラクターはいません。', className: 'log' });
        const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
        backButton.addEventListener('click', () => setStage('menu'));
        stageContainer.append(info, warn, backButton);
        return;
      }

      const actions = createElement('div', { className: 'stage-actions' });
      slots.forEach(slot => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: slotLabel(slot) });
        btn.addEventListener('click', () => {
          state.tempSlot = slot;
          setStage('chooseCharAnim');
        });
        actions.appendChild(btn);
      });

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.tempSlot = null;
        setStage('menu');
      });
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }

    function renderChooseCharAnim() {
      if (!state.tempSlot) {
        setStage('menu');
        return;
      }
      const info = createElement('p', { textContent: `選択中: ${slotLabel(state.tempSlot)}。新しい動き、または向きを選んでください。` });
      const actions = createElement('div', { className: 'stage-actions' });
      [['none', '動かない'], ['upDown', '浮いている'], ['shake', '左右に揺れる'], ['hop', 'ジャンプしている']].forEach(([value, label]) => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: label });
        btn.addEventListener('click', () => {
          appendFlowOp({ kind: 'charAnim', slot: state.tempSlot, anim: value });
          state.tempSlot = null;
          setStage('menu');
        });
        actions.appendChild(btn);
      });

      const flipButton = createElement('button', { className: 'flat', type: 'button', textContent: '向きを変える' });
      flipButton.addEventListener('click', () => {
        appendFlowOp({ kind: 'charFlip', slot: state.tempSlot });
        state.tempSlot = null;
        setStage('menu');
      });
      actions.appendChild(flipButton);

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.tempSlot = null;
        setStage('menu');
      });
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }
    function renderChooseTextType() {
      const info = createElement('p', { textContent: '文章はナレーションか会話かを選びます。' });
      const actions = createElement('div', { className: 'stage-actions' });
      const narrationButton = createElement('button', { className: 'flat', type: 'button', textContent: 'ナレーション' });
      narrationButton.addEventListener('click', () => {
        state.textDraft = { type: 'text', narration: true, speaker: null, text: '' };
        setStage('addText');
      });
      const dialogButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラのセリフ' });
      dialogButton.addEventListener('click', () => {
        state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
        setStage('chooseTextSpeaker');
      });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.append(narrationButton, dialogButton, cancelButton);
      stageContainer.append(info, actions);
    }

    function renderChooseTextSpeaker() {
      const slots = Array.from(getActiveSlots());
      const info = createElement('p', { textContent: '話すキャラクターの位置を選びます。' });
      if (slots.length === 0) {
        const warn = createElement('p', { textContent: '舞台にキャラクターがいないため、真ん中で話す扱いになります。', className: 'log' });
        const confirm = createElement('button', { className: 'primary', type: 'button', textContent: '真ん中で話す' });
        confirm.addEventListener('click', () => {
          state.textDraft.speaker = 'center';
          setStage('addText');
        });
        const cancel = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
        cancel.addEventListener('click', () => setStage('menu'));
        stageContainer.append(info, warn, confirm, cancel);
        return;
      }

      const actions = createElement('div', { className: 'stage-actions' });
      slots.forEach(slot => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: slotLabel(slot) });
        btn.addEventListener('click', () => {
          state.textDraft.speaker = slot;
          setStage('addText');
        });
        actions.appendChild(btn);
      });

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }

    function renderAddText() {
      const isNarration = state.textDraft.narration;
      const info = createElement('p', { textContent: isNarration ? 'ナレーションの文章を入力します。' : `${slotLabel(state.textDraft.speaker)}のセリフを入力します。` });
      const textarea = createElement('textarea');
      textarea.value = state.textDraft.text || '';
      textarea.placeholder = isNarration ? '例: こうして冒険は始まった。' : '例: さあ、行こう！';
      let addButton;
      
      textarea.addEventListener('input', () => {
        state.textDraft.text = textarea.value;
        if (addButton) {
          addButton.disabled = !(textarea.value || '').trim();
        }
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
        setStage('menu');
      });

      addButton = createElement('button', { className: 'primary', type: 'button', textContent: '文章を追加' });
      addButton.disabled = !(state.textDraft.text || '').trim();
      addButton.addEventListener('click', () => {
        if (!(state.textDraft.text || '').trim()) {
          alert('文章を入力してください。');
          return;
        }
        const op = {
          kind: 'text',
          text: state.textDraft.text.trim(),
          narration: state.textDraft.narration,
          slot: state.textDraft.narration ? null : state.textDraft.speaker || 'center'
        };
        appendFlowOp(op);
        state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
        setStage('menu');
      });

      actions.append(cancelButton, addButton);
      stageContainer.append(info, textarea, actions);
    }

    function renderAddWait() {
      const info = createElement('p', { textContent: '何秒待つか入力してください。' });
      const waitInput = createElement('input', { type: 'number', min: 0.5, step: 0.5, value: 1.0 });
      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      const addButton = createElement('button', { className: 'primary', type: 'button', textContent: '待機を追加' });
      addButton.addEventListener('click', () => {
        const sec = parseFloat(waitInput.value);
        if (!Number.isFinite(sec) || sec <= 0) {
          alert('正しい秒数を入力してください。');
          return;
        }
        appendFlowOp({ kind: 'wait', seconds: sec });
        setStage('menu');
      });
      actions.append(cancelButton, addButton);
      stageContainer.append(info, waitInput, actions);
    }

    function renderChangeBackground() {
      if (!state.pendingBackgroundChange) {
        state.pendingBackgroundChange = { type: '', youtubeId: '', assetKey: null, assetURL: '', libraryPath: null };
      }
      const info = createElement('p', { textContent: '変更後の背景を選択します。' });
      const typeLabel = createElement('label', { textContent: '背景タイプ' });
      const typeSelect = createElement('select');
      ['', 'youtube', 'image'].forEach(value => {
        const option = createElement('option', { value, textContent: value === '' ? '選択してください' : (value === 'youtube' ? 'YouTube' : '画像') });
        if (state.pendingBackgroundChange.type === value) option.selected = true;
        typeSelect.appendChild(option);
      });

      const youtubeLabel = createElement('label', { htmlFor: 'change-bg-youtube', textContent: 'YouTubeリンクまたはID' });
      const youtubeInput = createElement('input', { type: 'text', id: 'change-bg-youtube', value: state.pendingBackgroundChange.youtubeId, placeholder: 'https://youtu.be/...' });
      youtubeLabel.style.display = youtubeInput.style.display = state.pendingBackgroundChange.type === 'youtube' ? 'block' : 'none';

      const imageLabel = createElement('label', { htmlFor: 'change-bg-image', textContent: '背景画像 (アップロード)' });
      const imageInput = createElement('input', { type: 'file', id: 'change-bg-image', accept: 'image/*' });
      const showImageControls = state.pendingBackgroundChange.type === 'image';
      imageLabel.style.display = imageInput.style.display = showImageControls ? 'block' : 'none';

      let libraryContainer = null;
      if (state.pendingBackgroundChange.type === 'image') {
        libraryContainer = createElement('div', { className: 'asset-library' });

        const renderLibrary = () => {
          const libraryState = state.libraries.backgrounds;
          libraryContainer.innerHTML = '';

          const header = createElement('div', { className: 'asset-library-header' });
          const title = createElement('span', {
            className: 'asset-library-header-title',
            textContent: 'アップロード済みの背景画像'
          });
          header.appendChild(title);

          const refreshButton = createElement('button', {
            className: 'flat',
            type: 'button',
            textContent: libraryState.loading ? '読み込み中…' : '再読み込み'
          });
          refreshButton.disabled = libraryState.loading;
          refreshButton.addEventListener('click', async () => {
            try {
              await loadBackgroundLibrary(true);
            } catch (error) {
              console.error('Failed to refresh background library', error);
            } finally {
              if (state.stage === 'changeBG' && state.pendingBackgroundChange?.type === 'image') {
                renderStage();
              }
            }
          });
          header.appendChild(refreshButton);
          libraryContainer.appendChild(header);

          if (libraryState.error) {
            const errorMessage = createElement('p', { className: 'log', textContent: `読み込みエラー: ${libraryState.error}` });
            libraryContainer.appendChild(errorMessage);
            return;
          }

          if (libraryState.loading && libraryState.items.length === 0) {
            const loadingMessage = createElement('p', { className: 'log', textContent: '背景画像を読み込み中です…' });
            libraryContainer.appendChild(loadingMessage);
            return;
          }

          if (libraryState.items.length === 0) {
            const emptyMessage = createElement('p', { className: 'log', textContent: 'まだ利用可能な背景画像がありません。' });
            libraryContainer.appendChild(emptyMessage);
            return;
          }

          const grid = createElement('div', { className: 'asset-grid' });
          libraryState.items.forEach(item => {
            const button = createElement('button', { className: 'asset-thumb', type: 'button' });
            if (
              state.pendingBackgroundChange.libraryPath === item.fullPath ||
              (!state.pendingBackgroundChange.libraryPath && state.pendingBackgroundChange.assetURL === item.url)
            ) {
              button.classList.add('selected');
            }
            const image = document.createElement('img');
            applyLibraryThumbnail(image, item);
            const label = createElement('span', { className: 'asset-thumb-label', textContent: item.name });
            button.append(image, label);
            button.addEventListener('click', () => {
              state.pendingBackgroundChange.assetKey = null;
              state.pendingBackgroundChange.assetURL = item.url;
              state.pendingBackgroundChange.libraryPath = item.fullPath;
              renderStage();
            });
            grid.appendChild(button);
          });
          libraryContainer.appendChild(grid);
        };

        renderLibrary();

        if (!state.libraries.backgrounds.loaded && !state.libraries.backgrounds.loading) {
          loadBackgroundLibrary()
            .then(() => {
              if (state.stage === 'changeBG' && state.pendingBackgroundChange?.type === 'image') {
                renderStage();
              }
            })
            .catch(error => {
              console.error('Failed to load background library', error);
              if (state.stage === 'changeBG' && state.pendingBackgroundChange?.type === 'image') {
                renderStage();
              }
            });
        }
      }

      let nextButton;

      typeSelect.addEventListener('change', () => {
        state.pendingBackgroundChange.type = typeSelect.value;
        if (typeSelect.value !== 'youtube') state.pendingBackgroundChange.youtubeId = '';
        if (typeSelect.value !== 'image') {
          state.pendingBackgroundChange.assetKey = null;
          state.pendingBackgroundChange.assetURL = '';
          state.pendingBackgroundChange.libraryPath = null;
        }
        renderStage();
      });

      youtubeInput.addEventListener('input', () => {
        state.pendingBackgroundChange.youtubeId = youtubeInput.value.trim();
        if (nextButton) {
          nextButton.disabled = !isBackgroundReady(state.pendingBackgroundChange);
        }
      });

      imageInput.addEventListener('change', async () => {
        const file = imageInput.files?.[0];
        if (!file) return;
        const dataUrl = await fileToDataURL(file);
        state.pendingBackgroundChange.assetKey = storeAsset(dataUrl, 'background', file.name);
        state.pendingBackgroundChange.assetURL = '';
        state.pendingBackgroundChange.libraryPath = null;
        renderStage();
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.pendingBackgroundChange = null;
        setStage('menu');
      });

      nextButton = createElement('button', { className: 'primary', type: 'button', textContent: 'トランジションを選ぶ' });
      nextButton.disabled = !isBackgroundReady(state.pendingBackgroundChange);
      nextButton.addEventListener('click', () => {
        if (!state.pendingBackgroundChange) return;
        const type = state.pendingBackgroundChange.type;
        if (type === 'youtube' && !extractYouTubeID(state.pendingBackgroundChange.youtubeId)) {
          alert('有効なYouTubeリンクまたはIDを入力してください。');
          return;
        }
        if (type === 'image' && !state.pendingBackgroundChange.assetKey && !state.pendingBackgroundChange.assetURL) {
          alert('画像をアップロードするか、アップロード済みの背景から選択してください。');
          return;
        }
        setStage('chooseTransition');
      });

      actions.append(cancelButton, nextButton);

      const currentStatus = createElement('p', {
        className: 'log',
        textContent: state.pendingBackgroundChange.type === 'image'
          ? (state.pendingBackgroundChange.assetKey
              ? `選択済み: asset://${state.pendingBackgroundChange.assetKey}`
              : (state.pendingBackgroundChange.assetURL
                ? `選択済み: ${state.pendingBackgroundChange.libraryPath || state.pendingBackgroundChange.assetURL}`
                : '背景画像が未選択です。'))
          : 'YouTubeリンクを指定してください。'
      });

      const children = [info, typeLabel, typeSelect, youtubeLabel, youtubeInput, imageLabel, imageInput];
      if (libraryContainer) {
        children.push(libraryContainer);
      }
      if (state.pendingBackgroundChange.type === 'image') {
        children.push(currentStatus);
      }
      children.push(actions);

      stageContainer.append(...children);
    }
    function renderChooseTransition() {
      if (!state.pendingBackgroundChange) {
        setStage('menu');
        return;
      }
      const info = createElement('p', { textContent: '背景変更時の演出を選んでください。' });
      const actions = createElement('div', { className: 'stage-actions' });
      const blurButton = createElement('button', { className: 'flat', type: 'button', textContent: 'ブラー' });
      blurButton.addEventListener('click', () => {
        appendBGChangeFromPending('blur');
      });
      const switchButton = createElement('button', { className: 'flat', type: 'button', textContent: '切り替え' });
      switchButton.addEventListener('click', () => {
        appendBGChangeFromPending('switch');
      });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.pendingBackgroundChange = null;
        setStage('menu');
      });
      actions.append(blurButton, switchButton, cancelButton);
      stageContainer.append(info, actions);
    }

    function renderChooseCover() {
      const info = createElement('p', { textContent: 'クエスト一覧に表示するトップ画像（サムネイル）を設定します。' });
      const current = createElement('p', { className: 'log', textContent: state.cover.assetKey ? `選択済み: asset://${state.cover.assetKey}` : (state.cover.url ? `選択済みURL: ${state.cover.url}` : '未設定') });
      const sourceLabel = createElement('label', { textContent: '指定方法' });
      const sourceSelect = createElement('select');
      ['upload', 'url'].forEach(value => {
        const option = createElement('option', { value, textContent: value === 'upload' ? '画像をアップロード' : '画像URLを入力' });
        if ((!state.cover.assetKey && state.cover.url) && value === 'url') option.selected = true;
        if (state.cover.assetKey && value === 'upload') option.selected = true;
        sourceSelect.appendChild(option);
      });

      const fileLabel = createElement('label', { htmlFor: 'cover-image-file', textContent: 'サムネイル画像' });
      const fileInput = createElement('input', { type: 'file', id: 'cover-image-file', accept: 'image/*' });
      const urlLabel = createElement('label', { htmlFor: 'cover-image-url', textContent: 'サムネイル画像URL' });
      const urlInput = createElement('input', { type: 'url', id: 'cover-image-url', value: state.cover.url, placeholder: 'https://example.com/cover.png' });

      const updateVisibility = () => {
        const type = sourceSelect.value;
        fileLabel.style.display = fileInput.style.display = type === 'upload' ? 'block' : 'none';
        urlLabel.style.display = urlInput.style.display = type === 'url' ? 'block' : 'none';
      };
      updateVisibility();

      sourceSelect.addEventListener('change', () => {
        updateVisibility();
      });

      urlInput.addEventListener('input', () => {
        state.cover.url = urlInput.value.trim();
        state.cover.assetKey = null;
        renderQuestPreview();
      });

      fileInput.addEventListener('change', async () => {
        const file = fileInput.files?.[0];
        if (!file) return;
        const dataUrl = await fileToDataURL(file);
        state.cover.assetKey = storeAsset(dataUrl, 'cover', file.name);
        state.cover.url = '';
        renderQuestPreview();
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
      backButton.addEventListener('click', () => setStage('menu'));
      const doneButton = createElement('button', { className: 'primary', type: 'button', textContent: '完了' });
      doneButton.addEventListener('click', () => {
        if (sourceSelect.value === 'url' && !state.cover.url) {
          alert('URLを入力するか、アップロードを選択してください。');
          return;
        }
        if (sourceSelect.value === 'upload' && !state.cover.assetKey) {
          alert('画像をアップロードしてください。');
          return;
        }
        setStage('menu');
      });
      actions.append(backButton, doneButton);
      stageContainer.append(info, current, sourceLabel, sourceSelect, fileLabel, fileInput, urlLabel, urlInput, actions);
    }

    function renderAskThumbnail() {
      const info = createElement('p', { textContent: 'アプリでは最終確認画面です。JSONプレビューを確認し、必要であればサムネイルも設定してください。' });
      const summary = createElement('ul');
      summary.style.margin = '0';
      summary.style.paddingLeft = '1.25rem';
      summary.innerHTML = `
        <li>タイトル: ${state.title || '(未設定)'}</li>
        <li>背景: ${state.background.type || '(未設定)'}</li>
        <li>フロー数: ${state.flowOps.length}</li>
        <li>サムネイル: ${state.cover.assetKey ? 'asset://' + state.cover.assetKey : (state.cover.url || 'なし')}</li>
      `;
      const actions = createElement('div', { className: 'stage-actions' });
      const finishButton = createElement('button', { className: 'primary', type: 'button', textContent: '完了してメニューへ戻る' });
      finishButton.addEventListener('click', () => setStage('menu'));
      const coverButton = createElement('button', { className: 'flat', type: 'button', textContent: 'サムネイルを設定する' });
      coverButton.addEventListener('click', () => setStage('chooseCover'));
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.append(finishButton, coverButton, cancelButton);
      stageContainer.append(info, summary, actions);
    }
    function appendBGChangeFromPending(transition) {
      if (!state.pendingBackgroundChange) return;
      const pending = state.pendingBackgroundChange;
      const type = pending.type;
      if (type === 'youtube') {
        const id = extractYouTubeID(pending.youtubeId);
        if (!id) {
          alert('有効なYouTubeリンクまたはIDを入力してください。');
          return;
        }
        appendFlowOp({ kind: 'bgYouTube', youtubeID: id, transition });
      } else if (type === 'image') {
        appendFlowOp({ kind: 'bgImage', assetKey: pending.assetKey, assetURL: pending.assetURL, transition });
      }
      state.pendingBackgroundChange = null;
      setStage('menu');
    }

    function appendFlowOp(op) {
      state.flowOps.push(op);
      renderTimeline();
      renderQuestPreview();
    }

    function getActiveSlots() {
      const active = new Set();
      state.flowOps.forEach(op => {
        switch (op.kind) {
          case 'charAdd':
            if (op.slot) active.add(op.slot);
            break;
          case 'charRemove':
            if (op.slot) active.delete(op.slot);
            break;
        }
      });
      return active;
    }

    function slotLabel(slot) {
      switch (slot) {
        case 'left':
          return '左';
        case 'center':
          return '真ん中';
        case 'right':
          return '右';
        default:
          return 'ナレーション';
      }
    }

    function storeAsset(dataUrl, kind, name) {
      const key = `${kind}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
      state.assets[key] = { dataUrl, kind, name };
      return key;
    }

    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(file);
      });
    }
    
    function blobToDataURL(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error('データURLへの変換に失敗しました。'));
        reader.readAsDataURL(blob);
      });
    }

    function isHeicLikeFile(name = '') {
      return /\.hei[cf]$/i.test(name.trim());
    }

    async function ensureLibraryPreviewURL(item) {
      if (!item) return '';
      if (!isHeicLikeFile(item.name)) {
        item.previewUrl = item.url;
        return item.url;
      }
      if (item.previewUrl) {
        return item.previewUrl;
      }
      if (item.previewPromise) {
        return item.previewPromise;
      }

      const task = (async () => {
        if (typeof heic2any !== 'function') {
          throw new Error('HEIC変換ライブラリが利用できません。');
        }
        const response = await fetch(item.url);
        if (!response.ok) {
          throw new Error(`HEIC画像の取得に失敗しました: ${response.status}`);
        }
        const heicBlob = await response.blob();
        const converted = await heic2any({ blob: heicBlob, toType: 'image/png', quality: 0.92 });
        const outputBlob = Array.isArray(converted) ? converted[0] : converted;
        if (!(outputBlob instanceof Blob)) {
          throw new Error('HEIC画像の変換結果を読み取れませんでした。');
        }
        const dataUrl = await blobToDataURL(outputBlob);
        item.previewUrl = dataUrl;
        return dataUrl;
      })()
        .catch(error => {
          console.warn('Failed to convert HEIC asset', item.fullPath || item.name, error);
          item.previewUrl = item.url;
          return item.url;
        })
        .finally(() => {
          item.previewPromise = null;
        });

      item.previewPromise = task;
      return task;
    }

    function applyLibraryThumbnail(image, item) {
      if (!image || !item) return;
      const key = item.fullPath || item.url || item.name || '';
      image.alt = item.name || '';
      image.decoding = 'async';
      image.loading = 'lazy';

      if (!isHeicLikeFile(item.name)) {
        image.dataset.assetKey = key;
        image.classList.remove('asset-thumb-loading');
        image.src = item.url;
        return;
      }

      image.classList.add('asset-thumb-loading');
      image.dataset.assetKey = key;
      ensureLibraryPreviewURL(item)
        .then(url => {
          if (image.dataset.assetKey === key) {
            image.src = url;
          }
        })
        .finally(() => {
          if (image.dataset.assetKey === key) {
            image.classList.remove('asset-thumb-loading');
          }
        });
    }
    function renderTimeline() {
      timelineContainer.innerHTML = '';
      if (state.flowOps.length === 0) {
        const empty = createElement('p', { className: 'log', textContent: 'まだフローはありません。メニューから操作を追加してください。' });
        timelineContainer.appendChild(empty);
        return;
      }

      state.flowOps.forEach((op, index) => {
        const item = createElement('div', { className: 'timeline-item', role: 'listitem' });
        const textWrapper = createElement('div');
        const title = createElement('strong', { textContent: timelineTitle(op) });
        const subtitle = createElement('span', { textContent: timelineSubtitle(op) });
        textWrapper.append(title, subtitle);
        const removeButton = createElement('button', { className: 'danger', type: 'button', textContent: '削除' });
        removeButton.addEventListener('click', () => {
          state.flowOps.splice(index, 1);
          renderTimeline();
          renderQuestPreview();
        });
        item.append(textWrapper, removeButton);
        timelineContainer.appendChild(item);
      });
    }

    function timelineTitle(op) {
      switch (op.kind) {
        case 'charAdd':
          return `キャラ追加 (${slotLabel(op.slot)})`;
        case 'charRemove':
          return `キャラ退場 (${slotLabel(op.slot)})`;
        case 'charAnim':
          return `動き変更 (${slotLabel(op.slot)})`;
        case 'charFlip':
          return `向き変更 (${slotLabel(op.slot)})`;
        case 'text':
          return op.narration ? 'ナレーション' : `セリフ (${slotLabel(op.slot)})`;
        case 'wait':
          return 'ウェイト';
        case 'bgImage':
          return '背景変更 (画像)';
        case 'bgYouTube':
          return '背景変更 (YouTube)';
        default:
          return op.kind;
      }
    }

    function timelineSubtitle(op) {
      switch (op.kind) {
        case 'charAdd': {
          const scale = op.scale ? ` x${Number(op.scale).toFixed(2)}` : '';
          const source = op.assetURL ? op.assetURL : (op.assetKey ? `asset://${op.assetKey}` : '不明');
          return `${op.anim || 'none'}${scale} | ${source}`;
        }
        case 'charRemove':
          return '退場';
        case 'charAnim':
          return op.anim || 'none';
        case 'charFlip':
          return '左右反転';
        case 'text':
          return op.text || '';
        case 'wait':
          return `${op.seconds}s`;
        case 'bgImage':
          return `${op.transition || 'switch'} | ${op.assetURL || (op.assetKey ? 'asset://' + op.assetKey : '')}`;
        case 'bgYouTube':
          return `${op.transition || 'switch'} | ${op.youtubeID}`;
        default:
          return '';
      }
    }
    function extractYouTubeID(input) {
      if (!input) return '';
      const trimmed = input.trim();
      const direct = /^[a-zA-Z0-9_-]{11}$/;
      if (direct.test(trimmed)) return trimmed;
      const match = trimmed.match(/[?&]v=([a-zA-Z0-9_-]{11})/);
      if (match) return match[1];
      const short = trimmed.match(/youtu\.be\/([a-zA-Z0-9_-]{11})/);
      if (short) return short[1];
      return '';
    }

    function generateScriptLines() {
      const lines = [];
      state.flowOps.forEach(op => {
        switch (op.kind) {
          case 'text':
            if (!op.text) break;
            if (op.narration) {
              lines.push(':::textType(narration)');
              lines.push(op.text);
            } else {
              lines.push(':::textType(dialog)');
              const speaker = op.slot || 'center';
              lines.push(`:::speaker(${speaker})`);
              lines.push(op.text);
            }
            break;
          case 'wait':
            if (op.seconds != null) {
              lines.push(`:::wait(${Number(op.seconds)})`);
            }
            break;
          case 'charAdd': {
            const slot = op.slot || 'center';
            const anim = op.anim || 'none';
            const scale = Number(op.scale || 1).toFixed(2);
            const source = op.assetURL || (op.assetKey ? `asset://${op.assetKey}` : '');
            if (!source) break;
            lines.push(`:::charAdd(${slot},${source},${anim},${scale})`);
            break;
          }
          case 'charRemove':
            if (op.slot) lines.push(`:::charRemove(${op.slot})`);
            break;
          case 'charAnim':
            if (op.slot && op.anim) lines.push(`:::charAnim(${op.slot},${op.anim})`);
            break;
          case 'charFlip':
            if (op.slot) lines.push(`:::charFlip(${op.slot})`);
            break;
          case 'bgImage': {
            const source = op.assetURL || (op.assetKey ? `asset://${op.assetKey}` : '');
            if (!source) break;
            const transition = op.transition || 'switch';
            lines.push(`:::bgImage(${source},${transition})`);
            break;
          }
          case 'bgYouTube':
            if (op.youtubeID) {
              const transition = op.transition || 'switch';
              lines.push(`:::bgYouTube(${op.youtubeID},${transition})`);
            }
            break;
          default:
            break;
        }
      });
      return lines;
    }

    function collectQuest() {
      if (!state.title.trim()) return null;
      if (!isBackgroundReady(state.background)) return null;
      const bgType = state.background.type;
      let bgURL = '';
      if (bgType === 'youtube') {
        const id = extractYouTubeID(state.background.youtubeId);
        if (!id) return null;
        bgURL = id;
      } else if (bgType === 'image') {
        bgURL = state.background.assetURL || (state.background.assetKey ? `asset://${state.background.assetKey}` : '');
        if (!bgURL) return null;
      }

      const lines = generateScriptLines();
      const quest = {
        title: state.title.trim(),
        authorUID: state.authorUID || 'guest',
        bgType,
        bgURL,
        dialogLines: lines,
        flowOps: state.flowOps,
        assets: state.assets,
        cover: state.cover.assetKey ? { type: 'asset', key: state.cover.assetKey } : (state.cover.url ? { type: 'url', url: state.cover.url } : null),
        location: buildLocationPayload(),
        radius: Number(radiusInput.value) || 500
      };
      return quest;
    }

    function buildLocationPayload() {
      const mode = state.locationChoice.mode;
      const radius = Number(radiusInput.value) || 500;
      const payload = {
        mode,
        name: locationNameInput.value.trim() || null,
        detail: locationDetailInput.value.trim() || null,
        radius
      };
      if (mode === 'specificLocation' && state.selectedCoordinate) {
        payload.latitude = Number(state.selectedCoordinate.latitude.toFixed(6));
        payload.longitude = Number(state.selectedCoordinate.longitude.toFixed(6));
      } else if (mode === 'currentLocation' && state.selectedCoordinate) {
        payload.latitude = Number(state.selectedCoordinate.latitude.toFixed(6));
        payload.longitude = Number(state.selectedCoordinate.longitude.toFixed(6));
      } else {
        payload.latitude = null;
        payload.longitude = null;
      }
      return payload;
    }

    function renderQuestPreview() {
      const quest = collectQuest();
      if (quest) {
        questPreview.textContent = JSON.stringify(quest, null, 2);
      } else {
        const fallback = {
          title: state.title,
          authorUID: state.authorUID,
          bgType: state.background.type,
          bgURL: state.background.type === 'youtube' ? state.background.youtubeId : state.background.assetURL || state.background.assetKey,
          dialogLines: generateScriptLines(),
          flowOps: state.flowOps,
          assets: state.assets,
          location: buildLocationPayload()
        };
        questPreview.textContent = JSON.stringify(fallback, null, 2);
      }
    }
    function shortUid(uid) {
      if (!uid) return '';
      return uid.length > 12 ? `${uid.slice(0, 6)}…${uid.slice(-4)}` : uid;
    }
    
    function describeFirebaseUser(user) {
      if (!user) return '';
      const displayName = (user.displayName || '').trim();
      if (displayName) return displayName;
      const email = (user.email || '').trim();
      if (email) return email;
      return shortUid(user.uid);
    }

    function describeAuthError(error) {
      if (!error) return '';
      if (typeof error === 'string') return error;
      const code = error.code || '';
      switch (code) {
        case 'auth/popup-blocked':
          return 'ポップアップがブロックされました。ブラウザの設定で許可してください。';
        case 'auth/popup-closed-by-user':
          return 'ポップアップが閉じられたため、サインインが完了しませんでした。';
        case 'auth/cancelled-popup-request':
          return '別のサインイン処理が進行中です。数秒後に再試行してください。';
        case 'auth/credential-already-in-use':
          return 'このGoogleアカウントは既に他のユーザーに紐付いています。再度サインインを試みてください。';
        case 'auth/operation-not-supported-in-this-environment':
          return 'このブラウザではポップアップによるサインインがサポートされていません。別のブラウザをお試しください。';
        default:
          return error.message || String(error);
      }
    }

    function updateAuthUI() {
      if (!authStatus) return;
      const user = firebaseAuth?.currentUser || null;
      let message = '';
      if (!firebaseAuth) {
        message = 'Firebaseの初期化が完了するまでお待ちください。';
      } else if (authProcessing) {
        message = 'Googleアカウントに接続しています…';
      } else if (authErrorMessage) {
        message = `Googleサインインに失敗しました: ${authErrorMessage}`;
      } else if (user && !user.isAnonymous) {
        const label = describeFirebaseUser(user);
        message = `${label} としてサインインしています。`;
      } else if (user) {
        message = '匿名アカウントとして接続しています。Googleでサインインしてください。';
      } else {
        message = 'Googleアカウントでサインインしていません。';
      }

      authStatus.textContent = message;

      if (googleSignInButton) {
        googleSignInButton.disabled = authProcessing || !firebaseAuth;
      }
      if (googleSwitchButton) {
        const canSwitch = !!(firebaseAuth && user && !user.isAnonymous);
        googleSwitchButton.disabled = authProcessing || !canSwitch;
      }
      if (googleSignOutButton) {
        const canSignOut = !!(firebaseAuth && user);
        googleSignOutButton.disabled = authProcessing || !canSignOut;
      }
    }

    async function signInWithGoogle(options = {}) {
      const { clearSession = false, forceAccountSelection = false } = options;
      if (!firebaseAuth) {
        if (firebaseStatus) {
          firebaseStatus.textContent = 'Firebaseの初期化が完了していません。先に構成を確認してください。';
        }
        return;
      }
      if (authProcessing) return;

      authErrorMessage = '';
      authProcessing = true;
      updateAuthUI();

      try {
        if (clearSession && firebaseAuth.currentUser) {
          await firebaseAuth.signOut();
        }

        const provider = new firebase.auth.GoogleAuthProvider();
        if (forceAccountSelection) {
          provider.setCustomParameters({ prompt: 'select_account' });
        }

        const currentUser = firebaseAuth.currentUser;
        if (currentUser && currentUser.isAnonymous && typeof currentUser.linkWithPopup === 'function') {
          try {
            await currentUser.linkWithPopup(provider);
          } catch (error) {
            if (error?.code === 'auth/credential-already-in-use') {
              await firebaseAuth.signInWithPopup(provider);
            } else {
              throw error;
            }
          }
        } else {
          await firebaseAuth.signInWithPopup(provider);
        }

        if (firebaseStatus) {
          const user = firebaseAuth.currentUser;
          const label = describeFirebaseUser(user);
          firebaseStatus.textContent = label
            ? `Firebaseにサインインしました（${label}）`
            : 'Googleアカウントにサインインしました。';
        }
      } catch (error) {
        console.error('Google sign-in failed', error);
        authErrorMessage = describeAuthError(error);
        if (firebaseStatus) {
          firebaseStatus.textContent = `Googleサインインに失敗しました: ${authErrorMessage}`;
        }
      } finally {
        authProcessing = false;
        updateAuthUI();
      }
    }

    async function signOutFromFirebase() {
      if (!firebaseAuth) return;
      if (authProcessing) return;

      authErrorMessage = '';
      authProcessing = true;
      updateAuthUI();

      try {
        await firebaseAuth.signOut();
        if (firebaseStatus) {
          firebaseStatus.textContent = 'Googleアカウントからサインアウトしました。';
        }
      } catch (error) {
        console.error('Failed to sign out from Firebase', error);
        authErrorMessage = describeAuthError(error);
        if (firebaseStatus) {
          firebaseStatus.textContent = `ログアウトに失敗しました: ${authErrorMessage}`;
        }
      } finally {
        authProcessing = false;
        updateAuthUI();
      }
    }


    function initializeFirebase() {
      if (firebaseApp || firebaseInitError) {
        updateAuthUI();
        return;
      }
      if (typeof firebase === 'undefined') {
        firebaseInitError = new Error('Firebase SDK が読み込まれていません。');
        if (firebaseStatus) {
          firebaseStatus.textContent = firebaseInitError.message;
        }
        updateAuthUI();
        return;
      }
      try {
        const config = getActiveFirebaseConfig();
        if (!config || !config.apiKey) {
          if (firebaseStatus) {
            firebaseStatus.textContent = 'Firebase構成が未設定です。「Firebase設定」からWebアプリの構成を保存してください。';
          }
          updateAuthUI();
          return;
        }
        if (firebaseStatus) {
          const note = usingDefaultFirebaseConfig()
            ? 'FirebaseをiOSアプリ用のデフォルト構成で初期化しています。Web用の構成を保存するとこのメッセージは消えます。'
            : '保存済みのWeb構成でFirebaseを初期化しています。';
          firebaseStatus.textContent = note;
        }
        firebaseApp = firebase.apps.length ? firebase.app() : firebase.initializeApp(config);
        firebaseAuth = firebase.auth();
        firebaseFirestore = firebase.firestore();
        firebaseFirestore.settings({ ignoreUndefinedProperties: true });
        firebaseStorage = firebase.storage();
        if (firebaseStatus) {
          firebaseStatus.textContent = 'Firebaseを初期化しました。Googleアカウントでサインインしてください。';
        }

        firebaseAuth.onAuthStateChanged(user => {
          const previousUid = lastSignedInUid;
          if (user) {
            firebaseUserDisplayName = describeFirebaseUser(user);
            if (!user.isAnonymous) {
              lastSignedInUid = user.uid;
              if (!state.authorUID || state.authorUID === 'guest' || (previousUid && state.authorUID === previousUid)) {
                state.authorUID = user.uid;
                renderQuestPreview();
              }
              if (firebaseStatus) {
                firebaseStatus.textContent = `Firebaseにサインインしました（${firebaseUserDisplayName}）`;
              }
            } else {
              lastSignedInUid = null;
              if (firebaseStatus) {
                firebaseStatus.textContent = '匿名アカウントとして接続しています。Googleでサインインしてください。';
              }
            }
          } else {
            if (previousUid && state.authorUID === previousUid) {
              state.authorUID = 'guest';
              renderQuestPreview();
            }
            firebaseUserDisplayName = '';
            lastSignedInUid = null;
            if (firebaseStatus) {
              firebaseStatus.textContent = 'Firebaseのサインイン待機中です…';
            }
          }
          authProcessing = false;
          authErrorMessage = '';
          updateAuthUI();
        }, error => {
          console.error('Auth state listener error', error);
          authErrorMessage = describeAuthError(error);
          if (firebaseStatus) {
            firebaseStatus.textContent = `認証状態の監視中にエラーが発生しました: ${authErrorMessage}`;
          }
          updateAuthUI();
        });

        updateAuthUI();
      } catch (error) {
        firebaseInitError = error;
        if (firebaseStatus) {
          firebaseStatus.textContent = `Firebase初期化に失敗しました: ${error.message}`;
          if (error.code === 'auth/admin-restricted-operation') {
            firebaseStatus.textContent += `\n${adminRestrictedGuidance()}`;
          }
        }
        if (firebaseConfigLog && error.code === 'auth/admin-restricted-operation') {
          firebaseConfigLog.textContent = `auth/admin-restricted-operation: ${adminRestrictedGuidance()}`;
        }
        updateAuthUI();
      }
    }

    function waitForAuthUser(timeoutMs = 10000) {
      return new Promise((resolve, reject) => {
        if (firebaseAuth?.currentUser) {
          resolve(firebaseAuth.currentUser);
          return;
        }
        const startedAt = Date.now();
        const unsubscribe = firebaseAuth?.onAuthStateChanged(user => {
          if (user) {
            unsubscribe && unsubscribe();
            resolve(user);
          }
        }, error => {
          unsubscribe && unsubscribe();
          reject(error);
        });
        const timer = setInterval(() => {
          if (firebaseAuth?.currentUser) {
            clearInterval(timer);
            unsubscribe && unsubscribe();
            resolve(firebaseAuth.currentUser);
          } else if (Date.now() - startedAt > timeoutMs) {
            clearInterval(timer);
            unsubscribe && unsubscribe();
            reject(new Error('Firebaseのサインインがタイムアウトしました。'));
          }
        }, 250);
      });
    }

    async function ensureFirebaseReadyForUpload() {
      if (!firebaseApp && !firebaseInitError) {
        initializeFirebase();
      }
      if (firebaseInitError) {
        throw firebaseInitError;
      }
      if (!firebaseAuth || !firebaseFirestore || !firebaseStorage) {
        throw new Error('Firebaseの初期化が完了していません。');
      }
      const user = await waitForAuthUser();
      if (!user) {
        throw new Error('Firebaseのサインインが完了していません。Googleでサインインしてください。');
      }
      if (user.isAnonymous) {
        throw new Error('匿名アカウントではアップロードできません。Googleアカウントでサインインしてください。');
      }
      return user;
    }

    function getRequiredAssetKeys() {
      const keys = new Set();
      if (state.background.type === 'image' && state.background.assetKey) {
        keys.add(state.background.assetKey);
      }
      if (state.cover.assetKey) {
        keys.add(state.cover.assetKey);
      }
      state.flowOps.forEach(op => {
        if ((op.kind === 'charAdd' || op.kind === 'bgImage') && op.assetKey) {
          keys.add(op.assetKey);
        }
      });
      return Array.from(keys);
    }

    function storageFolderForKind(kind) {
      switch (kind) {
        case 'background':
          return 'questBGs';
        case 'cover':
          return 'questCovers';
        case 'character':
        default:
          return 'questChars';
      }
    }

    async function uploadRequiredAssets(assetKeys) {
      const map = {};
      const total = assetKeys.length;
      for (let i = 0; i < assetKeys.length; i += 1) {
        const key = assetKeys[i];
        const asset = state.assets[key];
        if (!asset) {
          throw new Error(`ローカルアセットが見つかりません: ${key}`);
        }
        if (uploadLog) {
          uploadLog.textContent = `画像をアップロード中 (${i + 1}/${total})…`;
        }
        const url = await uploadSingleAsset(key, asset);
        map[key] = url;
      }
      return map;
    }

    async function uploadSingleAsset(key, asset) {
      const folder = storageFolderForKind(asset.kind);
      const { blob, contentType, extension } = await prepareAssetForUpload(asset);
      if (!blob) throw new Error('画像の変換でBlobが得られませんでした。');

      const fileName = `${key}-${Date.now().toString(36)}.${extension}`;
      const storageRef = firebaseStorage.ref().child(`${folder}/${fileName}`);

      return new Promise((resolve, reject) => {
        const task = storageRef.put(blob, {
          contentType,
          cacheControl: 'public, max-age=31536000, immutable'
        });

        task.on(
          firebase.storage.TaskEvent.STATE_CHANGED,
          snap => {
            if (uploadLog && snap.totalBytes > 0) {
              const pct = Math.round((snap.bytesTransferred / snap.totalBytes) * 100);
              uploadLog.textContent = `アップロード中: ${pct}% (${asset.kind})`;
            }
          },
          err => {
            console.error('Storage upload error:', err);
            reject(err);
          },
          async () => {
            try {
              const url = await storageRef.getDownloadURL();
              resolve(url);
            } catch (e) {
              reject(e);
            }
          }
        );
      });
    }
    
    async function loadCharacterLibrary(forceRefresh = false) {
      const library = state.libraries?.characters;
      if (!library) return [];
      if (library.loading && library.promise) {
        return library.promise;
      }
      if (library.loaded && !forceRefresh) {
        return library.items;
      }
      if (forceRefresh) {
        library.loaded = false;
        library.items = [];
      }
      library.error = '';
      library.loading = true;

      const task = (async () => {
        try {
          await ensureFirebaseReadyForUpload();
          if (!firebaseStorage) {
            throw new Error('Firebase Storage が利用できません。');
          }
          const folder = storageFolderForKind('character');
          const folderRef = firebaseStorage.ref().child(folder);
          const refs = await listAllStorageItems(folderRef);
          const items = [];
          for (const ref of refs) {
            try {
              const url = await ref.getDownloadURL();
              items.push({ name: ref.name, fullPath: ref.fullPath, url });
            } catch (error) {
              console.warn('Failed to get download URL for character asset', ref.fullPath, error);
            }
          }
          items.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
          library.items = items;
          library.loaded = true;
          library.error = '';
          return items;
        } catch (error) {
          library.error = error?.message || String(error);
          library.loaded = false;
          throw error;
        }
      })().finally(() => {
        library.loading = false;
        library.promise = null;
      });

      library.promise = task;
      return task;
    }
    
    async function loadBackgroundLibrary(forceRefresh = false) {
      const library = state.libraries?.backgrounds;
      if (!library) return [];
      if (library.loading && library.promise) {
        return library.promise;
      }
      if (library.loaded && !forceRefresh) {
        return library.items;
      }
      if (forceRefresh) {
        library.loaded = false;
        library.items = [];
      }
      library.error = '';
      library.loading = true;

      const task = (async () => {
        try {
          await ensureFirebaseReadyForUpload();
          if (!firebaseStorage) {
            throw new Error('Firebase Storage が利用できません。');
          }
          const folder = storageFolderForKind('background');
          const folderRef = firebaseStorage.ref().child(folder);
          const refs = await listAllStorageItems(folderRef);
          const items = [];
          for (const ref of refs) {
            try {
              const url = await ref.getDownloadURL();
              items.push({ name: ref.name, fullPath: ref.fullPath, url });
            } catch (error) {
              console.warn('Failed to get download URL for background asset', ref.fullPath, error);
            }
          }
          items.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
          library.items = items;
          library.loaded = true;
          library.error = '';
          return items;
        } catch (error) {
          library.error = error?.message || String(error);
          library.loaded = false;
          throw error;
        }
      })().finally(() => {
        library.loading = false;
        library.promise = null;
      });

      library.promise = task;
      return task;
    }


    async function listAllStorageItems(folderRef) {
      const result = await folderRef.listAll();
      const items = [...result.items];
      for (const prefix of result.prefixes) {
        try {
          const nested = await listAllStorageItems(prefix);
          items.push(...nested);
        } catch (error) {
          console.warn('Failed to list storage prefix', prefix.fullPath, error);
        }
      }
      return items;
    }


    async function prepareAssetForUpload(asset) {
      const image = await loadImageFromDataUrl(asset.dataUrl);
      const maxLongSide = asset.kind === 'background' ? 1600 : asset.kind === 'cover' ? 640 : 768;
      const maxBytes = asset.kind === 'background' ? 1_400_000 : asset.kind === 'cover' ? 240_000 : 300_000;
      const preferPNG = asset.kind === 'character';
      let scale = Math.min(1, maxLongSide / Math.max(image.width, image.height));
      if (!Number.isFinite(scale) || scale <= 0) {
        scale = 1;
      }
      let quality = preferPNG ? 1 : 0.92;
      const mimeType = preferPNG ? 'image/png' : 'image/jpeg';
      let blob = await renderImageToBlob(image, scale, mimeType, quality);
      if (!blob) {
        throw new Error('画像の変換に失敗しました。');
      }
      if (!preferPNG) {
        while (blob.size > maxBytes && quality > 0.65) {
          quality = Math.max(0.65, quality - 0.07);
          const candidate = await renderImageToBlob(image, scale, mimeType, quality);
          if (!candidate) break;
          blob = candidate;
        }
      }
      while (blob.size > maxBytes && scale > 0.35) {
        scale *= 0.88;
        const candidate = await renderImageToBlob(image, scale, mimeType, preferPNG ? 1 : quality);
        if (!candidate) break;
        blob = candidate;
      }
      return {
        blob,
        contentType: mimeType,
        extension: preferPNG ? 'png' : 'jpg'
      };
    }

    function loadImageFromDataUrl(dataUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('画像の読み込みに失敗しました。'));
        img.src = dataUrl;
      });
    }

    function renderImageToBlob(image, scale, mimeType, quality) {
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(image.width * scale));
      canvas.height = Math.max(1, Math.round(image.height * scale));
      const ctx = canvas.getContext('2d');
      if (!ctx) return null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      return new Promise(resolve => {
        const q = typeof quality === 'number' ? quality : (mimeType === 'image/png' ? 1 : 0.92);
        try {
          canvas.toBlob(blob => {
            if (blob) {
              resolve(blob);
              return;
            }
            try {
              const dataURL = canvas.toDataURL(mimeType, q);
              const byteString = atob(dataURL.split(',')[1]);
              const ab = new ArrayBuffer(byteString.length);
              const ia = new Uint8Array(ab);
              for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
              resolve(new Blob([ab], { type: mimeType }));
            } catch {
              resolve(null);
            }
          }, mimeType, q);
        } catch {
          try {
            const dataURL = canvas.toDataURL(mimeType, q);
            const byteString = atob(dataURL.split(',')[1]);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
            resolve(new Blob([ab], { type: mimeType }));
          } catch {
            resolve(null);
          }
        }
      });
    }

    function generateFinalDialogLines(assetURLMap) {
      const lines = [];
      state.flowOps.forEach(op => {
        switch (op.kind) {
          case 'text':
            if (!op.text) break;
            if (op.narration) {
              lines.push(':::textType(narration)');
              lines.push(op.text);
            } else {
              lines.push(':::textType(dialog)');
              const speaker = op.slot || 'center';
              lines.push(`:::speaker(${speaker})`);
              lines.push(op.text);
            }
            break;
          case 'wait':
            if (op.seconds != null) {
              const sec = Number(op.seconds);
              lines.push(`:::wait(${Number.isFinite(sec) ? sec : op.seconds})`);
            }
            break;
          case 'charAdd': {
            const slot = op.slot || 'center';
            const anim = op.anim || 'none';
            const scale = Number(op.scale || 1).toFixed(2);
            const source = op.assetURL || (op.assetKey ? assetURLMap[op.assetKey] : '');
            if (!source) break;
            lines.push(`:::charAdd(${slot},${source},${anim},${scale})`);
            break;
          }
          case 'charRemove':
            if (op.slot) {
              lines.push(`:::charRemove(${op.slot})`);
            }
            break;
          case 'charAnim':
            if (op.slot && op.anim) {
              lines.push(`:::charAnim(${op.slot},${op.anim})`);
            }
            break;
          case 'charFlip':
            if (op.slot) {
              lines.push(`:::charFlip(${op.slot})`);
            }
            break;
          case 'bgImage': {
            const source = op.assetURL || (op.assetKey ? assetURLMap[op.assetKey] : '');
            if (!source) break;
            const transition = op.transition || 'switch';
            lines.push(`:::bgImage(${source},${transition})`);
            break;
          }
          case 'bgYouTube':
            if (op.youtubeID) {
              const transition = op.transition || 'switch';
              lines.push(`:::bgYouTube(${op.youtubeID},${transition})`);
            }
            break;
          default:
            break;
        }
      });
      return lines;
    }

    function resolveBackgroundURL(assetURLMap) {
      if (state.background.type === 'youtube') {
        const id = extractYouTubeID(state.background.youtubeId);
        return id || '';
      }
      if (state.background.type === 'image') {
        if (state.background.assetURL) {
          return state.background.assetURL;
        }
        if (state.background.assetKey && assetURLMap[state.background.assetKey]) {
          return assetURLMap[state.background.assetKey];
        }
      }
      return '';
    }

    function resolveCoverURL(assetURLMap) {
      if (state.cover.assetKey && assetURLMap[state.cover.assetKey]) {
        return assetURLMap[state.cover.assetKey];
      }
      if (state.cover.url) {
        return state.cover.url;
      }
      return '';
    }

    async function uploadQuestToFirebase(baseQuest) {
      const user = await ensureFirebaseReadyForUpload();
      const assetKeys = getRequiredAssetKeys();
      const assetURLMap = assetKeys.length > 0 ? await uploadRequiredAssets(assetKeys) : {};
      const backgroundURL = resolveBackgroundURL(assetURLMap);
      if (!backgroundURL) {
        throw new Error('背景のURLを決定できませんでした。画像またはYouTubeを確認してください。');
      }
      const coverURL = resolveCoverURL(assetURLMap);
      const dialogLines = generateFinalDialogLines(assetURLMap);
      const location = buildLocationPayload();
      const questDocument = {
        title: baseQuest.title.trim(),
        authorUID: user?.uid || baseQuest.authorUID || 'guest',
        bgType: state.background.type,
        bgURL: backgroundURL,
        charPosition: 'center',
        charAnim: 'none',
        dialogLines,
        coverURL: coverURL || '',
        charURL: '',
        placeType: 'dungeon',
        createdAt: firebase.firestore.Timestamp.fromDate(new Date()),
        locationMode: location.mode || 'everywhere',
        locationLatitude: typeof location.latitude === 'number' && Number.isFinite(location.latitude) ? location.latitude : null,
        locationLongitude: typeof location.longitude === 'number' && Number.isFinite(location.longitude) ? location.longitude : null,
        locationName: location.name || null,
        locationAddress: location.detail || null
      };

      const docRef = await firebaseFirestore.collection('quests').add(questDocument);
      return { id: docRef.id, questDocument };
    }

if (firebaseConfigSaveButton) {
      firebaseConfigSaveButton.addEventListener('click', async () => {
        const raw = firebaseConfigInput?.value?.trim() ?? '';
        if (!raw) {
          if (firebaseConfigLog) {
            firebaseConfigLog.textContent = 'Firebase構成のJSONを入力してください。';
          }
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          const validationError = validateFirebaseConfig(parsed);
          if (validationError) {
            if (firebaseConfigLog) {
              firebaseConfigLog.textContent = validationError;
            }
            return;
          }
          saveFirebaseConfig(parsed);
          updateFirebaseConfigEditor();
          if (firebaseConfigLog) {
            firebaseConfigLog.textContent = 'Firebase構成を保存しました。再接続を試みています…';
          }
          await reinitializeFirebase();
        } catch (error) {
          if (firebaseConfigLog) {
            firebaseConfigLog.textContent = `JSONの解析に失敗しました: ${error.message}`;
          }
        }
      });
    }

    if (firebaseConfigClearButton) {
      firebaseConfigClearButton.addEventListener('click', async () => {
        clearStoredFirebaseConfig();
        updateFirebaseConfigEditor();
        if (firebaseConfigLog) {
          firebaseConfigLog.textContent = '保存していたFirebase構成を削除しました。デフォルト構成で再接続します。';
        }
        await reinitializeFirebase();
      });
    }

    if (firebaseConfigTestButton) {
      firebaseConfigTestButton.addEventListener('click', async () => {
        if (firebaseConfigLog) {
          firebaseConfigLog.textContent = 'Firebaseへの接続を再試行しています…';
        }
        await reinitializeFirebase();
      });
    }

    document.getElementById('upload-quest').addEventListener('click', async () => {
      const quest = collectQuest();
      if (!quest) {
        uploadLog.textContent = '必須項目が不足しています。タイトル・背景・フローを確認してください。';
        return;
      }
      uploadLog.textContent = 'Firebaseと通信しています…';
      try {
        const { id } = await uploadQuestToFirebase(quest);
        uploadLog.textContent = `アップロードに成功しました。ドキュメントID: ${id}`;
      } catch (error) {
        console.error(error);
        let message = error?.message ?? String(error);
        if (error?.code === 'auth/admin-restricted-operation' && !message.includes('Firebaseコンソール')) {
          message += ` — ${adminRestrictedGuidance()}`;
        }
        uploadLog.textContent = `アップロードに失敗しました: ${message}`;
      }
    });

    document.getElementById('download-quest').addEventListener('click', () => {
      const quest = collectQuest();
      if (!quest) {
        uploadLog.textContent = 'JSONを出力するにはタイトル・背景・フローが必要です。';
        return;
      }
      const blob = new Blob([JSON.stringify(quest, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const safeTitle = quest.title.replace(/[^a-z0-9_-]+/gi, '_').toLowerCase() || 'quest';
      a.href = url;
      a.download = `${safeTitle}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      uploadLog.textContent = 'JSONファイルをダウンロードしました。';
    });

    document.getElementById('reset-all').addEventListener('click', () => {
      resetAll();
    });

    function resetAll() {
      state.stage = 'askTitle';
      state.title = '';
      state.authorUID = 'guest';
      state.background = { type: '', youtubeId: '', assetKey: null, assetURL: '', libraryPath: null };
      state.flowOps = [];
      state.assets = {};
      state.cover = { assetKey: null, url: '' };
      state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
      state.charDraft = {};
      state.pendingBackgroundChange = null;
      state.tempSlot = null;
      state.locationChoice = { mode: 'everywhere', name: '', detail: '' };
      latitudeInput.value = '';
      longitudeInput.value = '';
      locationModeInputs.forEach(input => { input.checked = input.value === 'everywhere'; });
      locationNameInput.value = '';
      locationDetailInput.value = '';
      if (state.map && state.marker && typeof mapkit !== 'undefined') {
        state.map.removeAnnotation(state.marker);
        state.marker = null;
      }
      state.selectedCoordinate = null;
      renderStage();
      uploadLog.textContent = 'すべてリセットしました。';
      mapLog.textContent = '位置情報がリセットされました。';
    }

    document.getElementById('toggle-theme').addEventListener('click', () => {
      document.body.classList.toggle('dark');
      if (state.map && typeof mapkit !== 'undefined') {
        state.map.colorScheme = document.body.classList.contains('dark') ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light;
      }
    });

    document.getElementById('mapkit-init').addEventListener('click', async () => {
      try {
        const initialized = await ensureMapKitInitialized();
        if (!initialized) return;
        state.mapkitInitialized = true;
        if (!state.map) {
          state.map = new mapkit.Map('map-main', {
            colorScheme: document.body.classList.contains('dark') ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light,
            showsScale: mapkit.FeatureVisibility.Always,
            isRotationEnabled: false
          });
          state.map.showsScale = mapkit.FeatureVisibility.Always;
          state.map.addEventListener('singleTap', event => {
            if (state.locationChoice.mode !== 'specificLocation') return;
            const { latitude, longitude } = event.coordinate;
            setQuestLocation(latitude, longitude);
          });
        } else {
          state.map.colorScheme = document.body.classList.contains('dark') ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light;
          state.map.showsScale = mapkit.FeatureVisibility.Always;
        }
        const lat = parseFloat(latitudeInput.value) || 35.680959;
        const lon = parseFloat(longitudeInput.value) || 139.767307;
        const radius = parseFloat(radiusInput.value) || 500;
        focusMap(lat, lon, radius);
        mapLog.textContent = `マップを初期化しました。現在地: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      } catch (error) {
        console.error(error);
        mapLog.textContent = 'MapKitの初期化に失敗しました。ブラウザのコンソールでエラーを確認してください。';
      }
    });

    if (geoGetBtn) {
      geoGetBtn.addEventListener('click', getBrowserGeolocation);
    }
    if (fallbackMapBtn) {
      fallbackMapBtn.addEventListener('click', initTokenlessMap);
    }
    if (geocodeRunBtn) {
      geocodeRunBtn.addEventListener('click', async () => {
        const q = (placeOrUrlInput.value || '').trim();
        if (!q) return;
        // 1) まず共有URLっぽいなら座標を抜く
        const parsed = tryParseGoogleMapsURL(q);
        if (parsed) {
          setLatLng(parsed.lat, parsed.lng, 'URL解析');
          // 必要なら代替マップを自動オープン
          if (!window.__leafletMap) initTokenlessMap();
          return;
        }
        // 2) 住所/地名はジオコーディング
        mapLog.textContent = '位置検索中…';
        try {
          const hit = await geocodeWithNominatim(q);
          if (!hit) {
            mapLog.textContent = '見つかりませんでした。キーワードを変えてお試しください。';
            alert('場所が見つかりませんでした。');
            return;
          }
          setLatLng(hit.lat, hit.lng, '検索');
          if (!window.__leafletMap) initTokenlessMap();
        } catch (e) {
          mapLog.textContent = `検索エラー: ${e.message}`;
          alert('検索に失敗しました。時間をおいてお試しください。');
        }
      });
    }
    function focusMap(latitude, longitude, radius) {
      if (!state.map || typeof mapkit === 'undefined') return;
      const coord = new mapkit.Coordinate(latitude, longitude);
      const cameraDistance = Math.max(200, (Number.isFinite(radius) ? radius : 500) * 2.5);
      state.map.setCenterAnimated(coord);
      state.map.cameraDistance = cameraDistance;
      setQuestLocation(latitude, longitude);
    }

    function setQuestLocation(latitude, longitude) {
      setLatLng(latitude, longitude, 'MapKit');
      if (state.marker && state.map && typeof mapkit !== 'undefined') {
        state.map.removeAnnotation(state.marker);
      }
      if (state.map && typeof mapkit !== 'undefined') {
        state.marker = new mapkit.MarkerAnnotation(new mapkit.Coordinate(latitude, longitude), {
          title: state.title || 'クエストポイント',
          subtitle: 'タップで再設定できます',
          color: '#6c4cff'
        });
        state.map.addAnnotation(state.marker);
      }
    }

    latitudeInput.addEventListener('change', () => {
      const lat = parseFloat(latitudeInput.value);
      const lon = parseFloat(longitudeInput.value);
      const radius = parseFloat(radiusInput.value) || 500;
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        focusMap(lat, lon, radius);
        mapLog.textContent = `緯度経度を手動設定: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      }
    });

    longitudeInput.addEventListener('change', () => {
      const lat = parseFloat(latitudeInput.value);
      const lon = parseFloat(longitudeInput.value);
      const radius = parseFloat(radiusInput.value) || 500;
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        focusMap(lat, lon, radius);
        mapLog.textContent = `緯度経度を手動設定: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      }
    });

    radiusInput.addEventListener('change', () => {
      const radius = parseFloat(radiusInput.value) || 500;
      if (state.selectedCoordinate) {
        focusMap(state.selectedCoordinate.latitude, state.selectedCoordinate.longitude, radius);
      }
      renderQuestPreview();
    });

    locationModeInputs.forEach(input => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        state.locationChoice.mode = input.value;
        if (input.value === 'everywhere') {
          state.selectedCoordinate = null;
          if (state.marker && state.map && typeof mapkit !== 'undefined') {
            state.map.removeAnnotation(state.marker);
            state.marker = null;
          }
          mapLog.textContent = 'すべての場所モードに切り替えました。';
        } else if (input.value === 'currentLocation') {
          mapLog.textContent = '現在地モードです。緯度経度を入力するか、マップで指定してください。';
        } else {
          mapLog.textContent = 'マップをタップして設置場所を指定してください。';
        }
        renderQuestPreview();
      });
    });

    locationNameInput.addEventListener('input', renderQuestPreview);
    locationDetailInput.addEventListener('input', renderQuestPreview);

    if (googleSignInButton) {
      googleSignInButton.addEventListener('click', () => {
        signInWithGoogle({ clearSession: false, forceAccountSelection: false });
      });
    }

    if (googleSwitchButton) {
      googleSwitchButton.addEventListener('click', () => {
        signInWithGoogle({ clearSession: true, forceAccountSelection: true });
      });
    }

    if (googleSignOutButton) {
      googleSignOutButton.addEventListener('click', () => {
        signOutFromFirebase();
      });
    }

    updateAuthUI();
    updateFirebaseConfigEditor();
    initializeFirebase();
    setStage('askTitle');
  </script>

  <div id="map" style="width:100%; height:60vh;"></div>

  <script>
    (async () => {
      if (typeof ensureMapKitInitialized === 'function') {
        const ready = await ensureMapKitInitialized();
        if (!ready) return;
      } else if (!window.__mapkitInited) {
        if (typeof mapkit !== 'undefined') {
          mapkit.init({
            authorizationCallback: async done => {
              const token = await fetch('https://mapkit-token-api.vercel.app/api/mapkit-token', {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
                mode: 'cors'
              }).then(r => r.text());
              done(token);
            }
          });
          window.__mapkitInited = true;
        }
      }

      if (typeof mapkit === 'undefined') return;
      const map = new mapkit.Map('map');
      map.region = new mapkit.CoordinateRegion(
        new mapkit.Coordinate(35.681236, 139.767125),
        new mapkit.CoordinateSpan(0.1, 0.1)
      );
      map.showsScale = mapkit.FeatureVisibility.Always;
    })();
  </script>
</body>
</html>
