<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DramaBirthQuest Web Uploader</title>
  <link rel="preconnect" href="https://cdn.apple-mapkit.com" crossorigin>
  <script src="https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Helvetica Neue", Arial, sans-serif;
      --accent: #6c4cff;
      --bg: #f5f5f7;
      --bg-dark: #1c1c1e;
      --card: rgba(255, 255, 255, 0.85);
      --card-dark: rgba(28, 28, 30, 0.85);
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, rgba(108, 76, 255, 0.2), rgba(0, 199, 190, 0.2)), var(--bg);
      color: #1f1f1f;
      display: flex;
      flex-direction: column;
    }

    body.dark {
      background: linear-gradient(135deg, rgba(108, 76, 255, 0.35), rgba(0, 199, 190, 0.35)), var(--bg-dark);
      color: #f5f5f7;
    }

    header {
      padding: 2rem clamp(1rem, 4vw, 3rem) 1.5rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2rem, 5vw, 3.5rem);
      font-weight: 700;
      color: var(--accent);
    }

    header p {
      margin-top: 0.75rem;
      font-size: clamp(1rem, 2.5vw, 1.25rem);
      line-height: 1.6;
    }

    main {
      flex: 1 1 auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      gap: clamp(1.5rem, 3vw, 2.5rem);
      padding: 0 clamp(1rem, 4vw, 3rem) 3rem;
    }

    .card {
      background: var(--card);
      border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(10px);
      padding: clamp(1.25rem, 3vw, 2rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    body.dark .card {
      background: var(--card-dark);
    }

    h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--accent);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    label {
      font-size: 0.95rem;
      font-weight: 600;
      display: block;
      margin-bottom: 0.4rem;
    }

    input[type="text"],
    input[type="number"],
    input[type="url"],
    input[type="file"],
    textarea,
    select {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 12px;
      border: 1px solid rgba(31, 31, 31, 0.15);
      background: rgba(255, 255, 255, 0.9);
      font-size: 0.95rem;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    body.dark input,
    body.dark textarea,
    body.dark select {
      background: rgba(44, 44, 46, 0.8);
      border-color: rgba(245, 245, 247, 0.2);
      color: inherit;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108, 76, 255, 0.2);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .map-wrapper {
      border-radius: 14px;
      overflow: hidden;
      height: 320px;
      position: relative;
      background: rgba(0, 0, 0, 0.05);
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button.primary {
      background: linear-gradient(135deg, #6c4cff, #00c7be);
      color: white;
      box-shadow: 0 14px 30px rgba(108, 76, 255, 0.35);
    }

    button.secondary {
      background: rgba(108, 76, 255, 0.1);
      color: var(--accent);
    }

    button.danger {
      background: rgba(255, 99, 132, 0.12);
      color: #ff496a;
    }

    button.flat {
      border-radius: 12px;
      background: rgba(108, 76, 255, 0.08);
      color: var(--accent);
      padding: 0.65rem 1rem;
      transition: background 0.2s ease;
    }

    button.flat:hover {
      background: rgba(108, 76, 255, 0.16);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.12);
    }

    details.config-panel {
      border-radius: 12px;
      border: 1px solid rgba(31, 31, 31, 0.12);
      padding: 0.75rem 1rem;
      background: rgba(255, 255, 255, 0.6);
    }

    body.dark details.config-panel {
      border-color: rgba(245, 245, 247, 0.2);
      background: rgba(44, 44, 46, 0.55);
    }

    details.config-panel summary {
      font-weight: 600;
      cursor: pointer;
      outline: none;
    }

    details.config-panel[open] {
      box-shadow: inset 0 0 0 1px rgba(108, 76, 255, 0.25);
    }

    .flex-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .flex-row .field {
      flex: 1 1 160px;
    }

    .stage-indicator {
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(31, 31, 31, 0.6);
    }

    body.dark .stage-indicator {
      color: rgba(245, 245, 247, 0.6);
    }

    .stage-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.7);
    }

    body.dark .stage-content {
      background: rgba(44, 44, 46, 0.7);
    }

    .stage-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .stage-actions button {
      flex: 1 1 180px;
    }

    .timeline {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-height: 280px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .timeline-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.65);
      gap: 0.75rem;
    }

    body.dark .timeline-item {
      background: rgba(44, 44, 46, 0.65);
    }

    .timeline-item strong {
      display: block;
      font-size: 0.95rem;
    }

    .timeline-item span {
      font-size: 0.85rem;
      color: rgba(31, 31, 31, 0.65);
    }

    body.dark .timeline-item span {
      color: rgba(245, 245, 247, 0.65);
    }

    .log {
      font-size: 0.85rem;
      line-height: 1.4;
      white-space: pre-wrap;
      min-height: 2.5rem;
    }

    pre#quest-preview {
      background: rgba(0, 0, 0, 0.75);
      color: #f5f5f5;
      border-radius: 12px;
      padding: 1rem;
      max-height: 320px;
      overflow: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    footer {
      text-align: center;
      padding: 1.5rem;
      font-size: 0.85rem;
      color: rgba(31, 31, 31, 0.6);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
      }

      body:not(.light) {
        background: linear-gradient(135deg, rgba(108, 76, 255, 0.35), rgba(0, 199, 190, 0.35)), var(--bg-dark);
        color: #f5f5f7;
      }

      footer {
        color: rgba(245, 245, 247, 0.6);
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>DramaBirthQuest Web Uploader</h1>
    <p>3DAdventureのクエストをウェブ上で設計し、Swiftアプリのクエスト作成画面と同じステップでシナリオを構築できます。<br>
      MapKitで配置したロケーション情報と合わせてアップロードまたはJSONとしてエクスポートしましょう。</p>
  </header>

  <main>
    <section class="card" aria-labelledby="mapkit-setup">
      <h2 id="mapkit-setup">MapKit 設定</h2>
      <p>MapKit JSのJWTトークンを入力してマップを初期化してください。トークンを持っていない場合は、<a href="https://developer.apple.com/documentation/mapkitjs" target="_blank" rel="noopener">Apple Developer</a>で発行できます。</p>
      <label for="mapkit-token">MapKit JWT</label>
      <input id="mapkit-token" type="text" placeholder="eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9...">
      <div class="button-row">
        <button class="primary" type="button" id="mapkit-init">Mapを初期化</button>
        <button class="secondary" type="button" id="toggle-theme">ライト/ダーク切替</button>
      </div>
      <div class="map-wrapper" role="region" aria-label="クエスト設置用マップ">
        <div id="map"></div>
      </div>
      <div class="flex-row">
        <div class="field">
          <label for="latitude">緯度 (Latitude)</label>
          <input id="latitude" type="number" step="any" placeholder="35.680959">
        </div>
        <div class="field">
          <label for="longitude">経度 (Longitude)</label>
          <input id="longitude" type="number" step="any" placeholder="139.767307">
        </div>
        <div class="field">
          <label for="regionRadius">表示範囲 (m)</label>
          <input id="regionRadius" type="number" min="100" value="500">
        </div>
      </div>
      <fieldset>
        <legend>配置モード</legend>
        <div class="flex-row">
          <label><input type="radio" name="location-mode" value="everywhere" checked> すべての場所</label>
          <label><input type="radio" name="location-mode" value="current"> 現在地を使用</label>
          <label><input type="radio" name="location-mode" value="specific"> マップで指定</label>
        </div>
      </fieldset>
      <label for="location-name">場所名称 (任意)</label>
      <input id="location-name" type="text" placeholder="例: 渋谷駅ハチ公前">
      <label for="location-detail">場所の補足 (任意)</label>
      <input id="location-detail" type="text" placeholder="例: 待ち合わせ広場付近">
      <p class="log" id="map-log">マップが未初期化です。JWTを入力して「Mapを初期化」を押してください。</p>
    </section>

    <section class="card" aria-labelledby="quest-settings">
      <h2 id="quest-settings">クエスト作成ウィザード</h2>
      <div class="stage-indicator" id="stage-indicator">STEP 1 / タイトルを決める</div>
      <div id="stage-container" class="stage-content" role="group" aria-live="polite"></div>

      <div>
        <h3 style="margin: 1rem 0 0.5rem; font-size: 1.05rem;">フロー (アプリ下部タイムラインと同等)</h3>
        <div id="timeline" class="timeline" role="list"></div>
      </div>

      <label for="quest-preview">JSONプレビュー</label>
      <pre id="quest-preview" aria-live="polite">{
  "title": "",
  "bgType": "",
  "bgURL": "",
  "dialogLines": [],
  "flowOps": [],
  "assets": {},
  "location": {
    "mode": "everywhere",
    "latitude": null,
    "longitude": null,
    "radius": 500
  }
}</pre>
    </section>

    <section class="card" aria-labelledby="upload-section">
      <h2 id="upload-section">アップロード &amp; エクスポート</h2>
      <p>アップロードボタンを押すと Firebase（プロジェクト: <code>poketquest-3a73d</code>）に直接保存され、iOSアプリと同じ形式でクエストが追加されます。MapKit の地点指定を行わなくても、位置情報フィールドはアプリで利用できる値が保存されます。</p>
      <p class="log" id="firebase-status">Firebaseの初期化を待機しています…</p>

      <details class="config-panel">
        <summary>Firebase設定（Web APIキーを貼り付け）</summary>
        <p>Firebaseコンソール &gt; プロジェクトの設定 &gt; 「アプリを追加」で Web アプリを登録し、表示される構成スニペットを JSON 形式で貼り付けてください。保存するとブラウザに暗号化せず保持されるため、共有端末では使用後に削除してください。</p>
        <label for="firebase-config-input">Firebase構成 JSON</label>
        <textarea id="firebase-config-input" rows="6" placeholder='{"apiKey":"AIza...","authDomain":"example.firebaseapp.com","projectId":"example","storageBucket":"example.appspot.com","messagingSenderId":"","appId":""}'></textarea>
        <div class="button-row">
          <button class="flat" type="button" id="save-firebase-config">保存</button>
          <button class="flat" type="button" id="clear-firebase-config">保存した設定を削除</button>
          <button class="flat" type="button" id="test-firebase-config">接続を再試行</button>
        </div>
        <p class="log" id="firebase-config-log">Web用の Firebase 構成が設定されていない場合、匿名サインインに失敗します。</p>
      </details>
      <div class="button-row">
        <button class="primary" type="button" id="upload-quest">アップロード</button>
        <button class="secondary" type="button" id="download-quest">JSONをダウンロード</button>
        <button class="danger" type="button" id="reset-all">すべてリセット</button>
      </div>

      <p class="log" id="upload-log">準備が整ったら「アップロード」を押してください。</p>
    </section>
  </main>

  <footer>
    3DAdventure Quest Builder &copy; 2025 — Swift版のロジックに合わせたステージ進行とJSONスキーマを採用しています。
  </footer>

  <script>
    const stageContainer = document.getElementById('stage-container');
    const stageIndicator = document.getElementById('stage-indicator');
    const timelineContainer = document.getElementById('timeline');
    const questPreview = document.getElementById('quest-preview');
    const mapLog = document.getElementById('map-log');
    const uploadLog = document.getElementById('upload-log');
    const firebaseStatus = document.getElementById('firebase-status');
    const firebaseConfigInput = document.getElementById('firebase-config-input');
    const firebaseConfigLog = document.getElementById('firebase-config-log');
    const firebaseConfigSaveButton = document.getElementById('save-firebase-config');
    const firebaseConfigClearButton = document.getElementById('clear-firebase-config');
    const firebaseConfigTestButton = document.getElementById('test-firebase-config');
    
    const latitudeInput = document.getElementById('latitude');
    const longitudeInput = document.getElementById('longitude');
    const radiusInput = document.getElementById('regionRadius');
    const locationModeInputs = Array.from(document.querySelectorAll('input[name="location-mode"]'));
    const locationNameInput = document.getElementById('location-name');
    const locationDetailInput = document.getElementById('location-detail');

    const state = {
      map: null,
      marker: null,
      selectedCoordinate: null,
      stage: 'askTitle',
      title: '',
      authorUID: 'guest',
      background: { type: '', youtubeId: '', assetKey: null, assetURL: '' },
      flowOps: [],
      assets: {},
      cover: { assetKey: null, url: '' },
      allowFinishOptions: false,
      textDraft: { type: 'text', narration: false, speaker: 'center', text: '' },
      charDraft: {},
      pendingBackgroundChange: null,
      tempSlot: null,
      locationChoice: { mode: 'everywhere', name: '', detail: '' }
    };

    const FIREBASE_CONFIG_STORAGE_KEY = 'dbq-firebase-config';

    let firebaseApp = null;
    let firebaseAuth = null;
    let firebaseFirestore = null;
    let firebaseStorage = null;
    let firebaseInitError = null;
    let firebaseUserIdPreview = '';
    let firebaseConfig = loadStoredFirebaseConfig();

    const DEFAULT_FIREBASE_CONFIG = {
      apiKey: 'AIzaSyB0bUTeC-uXTW8SZ-iGSCeTCR35YegtTCs',
      authDomain: 'poketquest-3a73d.firebaseapp.com',
      projectId: 'poketquest-3a73d',
      storageBucket: 'poketquest-3a73d.appspot.com',
      messagingSenderId: '254784688722',
      appId: '1:254784688722:ios:0742423c0e83009fc8058b'
    };

    function loadStoredFirebaseConfig() {
      if (!('localStorage' in window)) return null;
      try {
        const raw = window.localStorage.getItem(FIREBASE_CONFIG_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
          return parsed;
        }
      } catch (error) {
        console.warn('Failed to read stored Firebase config', error);
      }
      return null;
    }

    function saveFirebaseConfig(config) {
      if (!('localStorage' in window)) return;
      try {
        window.localStorage.setItem(FIREBASE_CONFIG_STORAGE_KEY, JSON.stringify(config));
        firebaseConfig = config;
      } catch (error) {
        console.warn('Failed to save Firebase config', error);
        firebaseConfig = config;
      }
    }

    function clearStoredFirebaseConfig() {
      if (!('localStorage' in window)) return;
      try {
        window.localStorage.removeItem(FIREBASE_CONFIG_STORAGE_KEY);
      } catch (error) {
        console.warn('Failed to clear Firebase config', error);
      }
      firebaseConfig = null;
    }

    function validateFirebaseConfig(config) {
      if (!config || typeof config !== 'object') {
        return 'JSONがオブジェクト形式ではありません。';
      }
      const requiredFields = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'appId'];
      for (const field of requiredFields) {
        if (typeof config[field] !== 'string' || !config[field]) {
          return `必須フィールド「${field}」が見つからないか空です。`;
        }
      }
      return null;
    }

    function updateFirebaseConfigEditor() {
      if (!firebaseConfigInput || !firebaseConfigLog) return;
      if (firebaseConfig) {
        firebaseConfigInput.value = JSON.stringify(firebaseConfig, null, 2);
        firebaseConfigLog.textContent = 'Web用のFirebase構成を保存しています。この設定で接続を試みます。';
      } else {
        firebaseConfigInput.value = '';
        firebaseConfigLog.textContent = 'Web用の構成が未保存のため、iOSアプリ用のデフォルト設定で接続を試みます（制限されている場合はエラーになります）。';
      }
    }

    function usingDefaultFirebaseConfig() {
      return !firebaseConfig;
    }

    function getActiveFirebaseConfig() {
      return firebaseConfig || DEFAULT_FIREBASE_CONFIG;
    }

    async function resetFirebaseState() {
      if (firebaseApp && typeof firebaseApp.delete === 'function') {
        try {
          await firebaseApp.delete();
        } catch (error) {
          console.warn('Failed to delete Firebase app before reinitializing', error);
        }
      }
      firebaseApp = null;
      firebaseAuth = null;
      firebaseFirestore = null;
      firebaseStorage = null;
      firebaseInitError = null;
      firebaseUserIdPreview = '';
    }

    async function reinitializeFirebase() {
      await resetFirebaseState();
      initializeFirebase();
    }

    function adminRestrictedGuidance() {
      return 'Firebaseコンソールで Web アプリを作成し、そこで発行された Web APIキーと構成をこのページの「Firebase設定」に保存してください。あわせて匿名サインインが有効になっているか確認してください。';
    }
    function setStage(next) {
      state.stage = next;
      renderStage();
    }

    function generateStageLabel(stage) {
      switch (stage) {
        case 'askTitle':
          return 'STEP 1 / タイトルを決める';
        case 'askBackground':
          return 'STEP 2 / 初期背景を選ぶ';
        case 'menu':
          return 'STEP 3 / 次のアクションを選択';
        case 'addCharacter':
          return 'キャラクターを登場させる';
        case 'removeCharacter':
          return 'キャラクターを退場させる';
        case 'changeCharMotionTarget':
          return '動きを変える対象を選ぶ';
        case 'chooseCharAnim':
          return 'キャラの動きを決める';
        case 'chooseTextType':
          return '文章の種類を選ぶ';
        case 'chooseTextSpeaker':
          return '話者を決める';
        case 'addText':
          return 'セリフ / ナレーションを入力';
        case 'addWait':
          return '何もしない時間を追加';
        case 'changeBG':
          return '背景を変更する';
        case 'chooseTransition':
          return '背景トランジションを選ぶ';
        case 'chooseCover':
          return 'トップ画像を設定';
        case 'askThumbnail':
          return '仕上げと確認';
        default:
          return 'クエスト作成';
      }
    }

    function renderStage() {
      stageIndicator.textContent = generateStageLabel(state.stage);
      stageContainer.innerHTML = '';
      switch (state.stage) {
        case 'askTitle':
          renderAskTitle();
          break;
        case 'askBackground':
          renderAskBackground();
          break;
        case 'menu':
          renderMenu();
          break;
        case 'addCharacter':
          renderAddCharacter();
          break;
        case 'removeCharacter':
          renderRemoveCharacter();
          break;
        case 'changeCharMotionTarget':
          renderChangeCharMotionTarget();
          break;
        case 'chooseCharAnim':
          renderChooseCharAnim();
          break;
        case 'chooseTextType':
          renderChooseTextType();
          break;
        case 'chooseTextSpeaker':
          renderChooseTextSpeaker();
          break;
        case 'addText':
          renderAddText();
          break;
        case 'addWait':
          renderAddWait();
          break;
        case 'changeBG':
          renderChangeBackground();
          break;
        case 'chooseTransition':
          renderChooseTransition();
          break;
        case 'chooseCover':
          renderChooseCover();
          break;
        case 'askThumbnail':
          renderAskThumbnail();
          break;
        default:
          stageContainer.textContent = '未定義のステージです。';
      }
      renderTimeline();
      renderQuestPreview();
    }

    function createElement(tag, options = {}) {
      const el = document.createElement(tag);
      if (options.className) el.className = options.className;
      if (options.textContent !== undefined) el.textContent = options.textContent;
      if (options.innerHTML !== undefined) el.innerHTML = options.innerHTML;
      if (options.type) el.type = options.type;
      if (options.value !== undefined) el.value = options.value;
      if (options.placeholder !== undefined) el.placeholder = options.placeholder;
      if (options.min !== undefined) el.min = options.min;
      if (options.max !== undefined) el.max = options.max;
      if (options.step !== undefined) el.step = options.step;
      if (options.checked !== undefined) el.checked = options.checked;
      if (options.disabled !== undefined) el.disabled = options.disabled;
      if (options.htmlFor) el.htmlFor = options.htmlFor;
      if (options.multiple !== undefined) el.multiple = options.multiple;
      if (options.accept !== undefined) el.accept = options.accept;
      if (options.id) el.id = options.id;
      return el;
    }

    function renderAskTitle() {
      const titleLabel = createElement('label', { htmlFor: 'quest-title-input', textContent: 'クエストタイトル' });
      const titleInput = createElement('input', { type: 'text', id: 'quest-title-input', value: state.title, placeholder: '例: 失われた記憶のかけら' });
      titleInput.addEventListener('input', () => {
        state.title = titleInput.value;
        renderQuestPreview();
        renderStage();
      });

      const authorLabel = createElement('label', { htmlFor: 'quest-author-input', textContent: '作者UID (未ログインの場合は guest)' });
      const authorInput = createElement('input', { type: 'text', id: 'quest-author-input', value: state.authorUID, placeholder: 'guest' });
      authorInput.addEventListener('input', () => {
        state.authorUID = authorInput.value.trim() || 'guest';
        renderQuestPreview();
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const nextButton = createElement('button', { className: 'primary', type: 'button', textContent: '次へ（背景を決める）' });
      nextButton.disabled = !state.title.trim();
      nextButton.addEventListener('click', () => setStage('askBackground'));
      actions.appendChild(nextButton);

      stageContainer.append(titleLabel, titleInput, authorLabel, authorInput, actions);
    }
    function renderAskBackground() {
      const info = createElement('p', { textContent: 'アプリと同様に、最初に表示する背景を選択します。YouTube動画か画像のどちらかを指定してください。' });
      const typeLabel = createElement('label', { textContent: '背景タイプ' });
      const typeSelect = createElement('select');
      ['', 'youtube', 'image'].forEach(value => {
        const option = createElement('option', { value, textContent: value === '' ? '選択してください' : (value === 'youtube' ? 'YouTube' : '画像') });
        if (state.background.type === value) option.selected = true;
        typeSelect.appendChild(option);
      });

      const youtubeLabel = createElement('label', { htmlFor: 'bg-youtube-input', textContent: 'YouTubeリンクまたはID' });
      const youtubeInput = createElement('input', { type: 'text', id: 'bg-youtube-input', value: state.background.youtubeId, placeholder: 'https://youtu.be/...' });
      youtubeLabel.style.display = youtubeInput.style.display = state.background.type === 'youtube' ? 'block' : 'none';

      const imageLabel = createElement('label', { htmlFor: 'bg-image-input', textContent: '背景画像 (アップロード)' });
      const imageInput = createElement('input', { type: 'file', id: 'bg-image-input', accept: 'image/*' });
      imageLabel.style.display = imageInput.style.display = state.background.type === 'image' ? 'block' : 'none';

      const imageURLLabel = createElement('label', { htmlFor: 'bg-image-url', textContent: '背景画像URL (アップロードしない場合)' });
      const imageURLInput = createElement('input', { type: 'url', id: 'bg-image-url', value: state.background.assetURL, placeholder: 'https://example.com/background.png' });
      imageURLLabel.style.display = imageURLInput.style.display = state.background.type === 'image' ? 'block' : 'none';

      typeSelect.addEventListener('change', () => {
        state.background.type = typeSelect.value;
        if (typeSelect.value !== 'youtube') state.background.youtubeId = '';
        if (typeSelect.value !== 'image') {
          state.background.assetKey = null;
          state.background.assetURL = '';
        }
        renderStage();
      });

      youtubeInput.addEventListener('input', () => {
        state.background.youtubeId = youtubeInput.value.trim();
        renderQuestPreview();
      });

      imageURLInput.addEventListener('input', () => {
        state.background.assetURL = imageURLInput.value.trim();
        renderQuestPreview();
      });

      imageInput.addEventListener('change', async () => {
        const file = imageInput.files?.[0];
        if (!file) return;
        const dataUrl = await fileToDataURL(file);
        const key = storeAsset(dataUrl, 'background', file.name);
        state.background.assetKey = key;
        state.background.assetURL = '';
        renderQuestPreview();
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
      backButton.addEventListener('click', () => setStage('askTitle'));
      const nextButton = createElement('button', { className: 'primary', type: 'button', textContent: '次へ（メニューへ）' });
      nextButton.disabled = !isBackgroundReady(state.background);
      nextButton.addEventListener('click', () => setStage('menu'));

      actions.append(backButton, nextButton);

      stageContainer.append(info, typeLabel, typeSelect, youtubeLabel, youtubeInput, imageLabel, imageInput, imageURLLabel, imageURLInput, actions);
    }

    function isBackgroundReady(bg) {
      if (bg.type === 'youtube') {
        return !!extractYouTubeID(bg.youtubeId);
      }
      if (bg.type === 'image') {
        return !!bg.assetKey || !!bg.assetURL;
      }
      return false;
    }

    function renderMenu() {
      state.allowFinishOptions = state.flowOps.length > 0;
      const info = createElement('p', { textContent: 'Swiftアプリのメニューと同じ選択肢です。追加したい操作を選んでください。' });
      const actions = createElement('div', { className: 'stage-actions' });

      const addCharButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラクターを登場させる' });
      addCharButton.addEventListener('click', () => setStage('addCharacter'));
      actions.appendChild(addCharButton);

      const activeSlots = getActiveSlots();
      if (activeSlots.size > 0) {
        const removeButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラクターを消す' });
        removeButton.addEventListener('click', () => setStage('removeCharacter'));
        actions.appendChild(removeButton);

        const changeMotionButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラクターの動きを変える / 向きを変える' });
        changeMotionButton.addEventListener('click', () => setStage('changeCharMotionTarget'));
        actions.appendChild(changeMotionButton);
      }

      const textButton = createElement('button', { className: 'flat', type: 'button', textContent: '文章を入れる' });
      textButton.addEventListener('click', () => setStage('chooseTextType'));
      actions.appendChild(textButton);

      const waitButton = createElement('button', { className: 'flat', type: 'button', textContent: '少し待つ（ウェイト）' });
      waitButton.addEventListener('click', () => setStage('addWait'));
      actions.appendChild(waitButton);

      const bgButton = createElement('button', { className: 'flat', type: 'button', textContent: '背景を変える' });
      bgButton.addEventListener('click', () => {
        state.pendingBackgroundChange = { type: '', youtubeId: '', assetKey: null, assetURL: '' };
        setStage('changeBG');
      });
      actions.appendChild(bgButton);

      const coverButton = createElement('button', { className: 'flat', type: 'button', textContent: 'トップ画像（サムネ）を選ぶ' });
      coverButton.addEventListener('click', () => setStage('chooseCover'));
      actions.appendChild(coverButton);

      if (state.allowFinishOptions) {
        const finishButton = createElement('button', { className: 'primary', type: 'button', textContent: 'これで終わり（仕上げへ）' });
        finishButton.addEventListener('click', () => setStage('askThumbnail'));
        actions.appendChild(finishButton);
      }

      const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '背景をやり直す' });
      backButton.addEventListener('click', () => setStage('askBackground'));
      actions.appendChild(backButton);

      stageContainer.append(info, actions);
    }
    function renderAddCharacter() {
      const info = createElement('p', { textContent: '登場させたいキャラクターの画像と配置、動きを設定します。' });

      const sourceLabel = createElement('label', { textContent: '画像の指定方法' });
      const sourceSelect = createElement('select');
      ['upload', 'url'].forEach(value => {
        const option = createElement('option', { value, textContent: value === 'upload' ? '画像をアップロード' : '画像URLを入力' });
        if (!state.charDraft.source && value === 'upload') {
          state.charDraft.source = 'upload';
        }
        if (state.charDraft.source === value) option.selected = true;
        sourceSelect.appendChild(option);
      });

      const fileLabel = createElement('label', { htmlFor: 'char-image-file', textContent: 'キャラクター画像' });
      const fileInput = createElement('input', { type: 'file', id: 'char-image-file', accept: 'image/*' });
      fileLabel.style.display = sourceSelect.value === 'upload' ? 'block' : 'none';
      fileInput.style.display = sourceSelect.value === 'upload' ? 'block' : 'none';

      const urlLabel = createElement('label', { htmlFor: 'char-image-url', textContent: '画像URL' });
      const urlInput = createElement('input', { type: 'url', id: 'char-image-url', placeholder: 'https://example.com/character.png', value: state.charDraft.assetURL || '' });
      urlLabel.style.display = urlInput.style.display = sourceSelect.value === 'url' ? 'block' : 'none';

      const positionLabel = createElement('label', { textContent: '配置位置' });
      const positionSelect = createElement('select');
      const occupied = getActiveSlots();
      [['left', '左'], ['center', '真ん中'], ['right', '右']].forEach(([value, label]) => {
        const option = createElement('option', { value, textContent: label });
        option.disabled = occupied.has(value);
        if (!option.disabled && !state.charDraft.slot) {
          state.charDraft.slot = value;
          option.selected = true;
        }
        if (state.charDraft.slot === value) option.selected = true;
        positionSelect.appendChild(option);
      });

      const scaleLabel = createElement('label', { htmlFor: 'char-scale', textContent: '表示倍率 (0.5〜2.0)' });
      const scaleInput = createElement('input', { type: 'number', id: 'char-scale', min: 0.5, max: 2, step: 0.1, value: state.charDraft.scale || 1.0 });

      const animLabel = createElement('label', { textContent: '初期モーション' });
      const animSelect = createElement('select');
      [['none', '動かない'], ['upDown', '浮いている'], ['shake', '左右に揺れる'], ['hop', 'ジャンプしている']].forEach(([value, label]) => {
        const option = createElement('option', { value, textContent: label });
        if ((state.charDraft.anim || 'none') === value) option.selected = true;
        animSelect.appendChild(option);
      });

      sourceSelect.addEventListener('change', () => {
        state.charDraft.source = sourceSelect.value;
        renderStage();
      });

      urlInput.addEventListener('input', () => {
        state.charDraft.assetURL = urlInput.value.trim();
      });

      positionSelect.addEventListener('change', () => {
        state.charDraft.slot = positionSelect.value;
      });

      scaleInput.addEventListener('input', () => {
        const val = parseFloat(scaleInput.value);
        if (Number.isFinite(val)) {
          state.charDraft.scale = val;
        }
      });

      animSelect.addEventListener('change', () => {
        state.charDraft.anim = animSelect.value;
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.charDraft = {};
        setStage('menu');
      });

      const addButton = createElement('button', { className: 'primary', type: 'button', textContent: 'キャラクターを追加' });
      addButton.addEventListener('click', async () => {
        try {
          if (!state.charDraft.slot) {
            alert('配置できる位置がありません。');
            return;
          }
          let assetKey = null;
          let assetURL = '';
          if ((state.charDraft.source || 'upload') === 'upload') {
            const file = fileInput.files?.[0];
            if (!file) {
              alert('キャラクター画像を選択してください。');
              return;
            }
            const dataUrl = await fileToDataURL(file);
            assetKey = storeAsset(dataUrl, 'character', file.name);
          } else {
            if (!urlInput.value.trim()) {
              alert('画像URLを入力してください。');
              return;
            }
            assetURL = urlInput.value.trim();
          }

          const op = {
            kind: 'charAdd',
            slot: state.charDraft.slot,
            anim: state.charDraft.anim || 'none',
            scale: Number(state.charDraft.scale || 1.0),
            assetKey,
            assetURL
          };
          appendFlowOp(op);
          state.charDraft = {};
          setStage('menu');
        } catch (error) {
          console.error(error);
          alert('画像の読み込みに失敗しました。');
        }
      });

      actions.append(cancelButton, addButton);

      stageContainer.append(info, sourceLabel, sourceSelect, fileLabel, fileInput, urlLabel, urlInput, positionLabel, positionSelect, scaleLabel, scaleInput, animLabel, animSelect, actions);
    }

    function renderRemoveCharacter() {
      const info = createElement('p', { textContent: '退場させたいキャラクターの位置を選択してください。' });
      const slots = Array.from(getActiveSlots());
      if (slots.length === 0) {
        const warn = createElement('p', { textContent: '現在舞台にキャラクターはいません。', className: 'log' });
        const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
        backButton.addEventListener('click', () => setStage('menu'));
        stageContainer.append(info, warn, backButton);
        return;
      }

      const actions = createElement('div', { className: 'stage-actions' });
      slots.forEach(slot => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: slotLabel(slot) });
        btn.addEventListener('click', () => {
          appendFlowOp({ kind: 'charRemove', slot });
          setStage('menu');
        });
        actions.appendChild(btn);
      });

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }

    function renderChangeCharMotionTarget() {
      const info = createElement('p', { textContent: '動きを変えたいキャラクターを選択してください。' });
      const slots = Array.from(getActiveSlots());
      if (slots.length === 0) {
        const warn = createElement('p', { textContent: '現在舞台にキャラクターはいません。', className: 'log' });
        const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
        backButton.addEventListener('click', () => setStage('menu'));
        stageContainer.append(info, warn, backButton);
        return;
      }

      const actions = createElement('div', { className: 'stage-actions' });
      slots.forEach(slot => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: slotLabel(slot) });
        btn.addEventListener('click', () => {
          state.tempSlot = slot;
          setStage('chooseCharAnim');
        });
        actions.appendChild(btn);
      });

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.tempSlot = null;
        setStage('menu');
      });
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }

    function renderChooseCharAnim() {
      if (!state.tempSlot) {
        setStage('menu');
        return;
      }
      const info = createElement('p', { textContent: `選択中: ${slotLabel(state.tempSlot)}。新しい動き、または向きを選んでください。` });
      const actions = createElement('div', { className: 'stage-actions' });
      [['none', '動かない'], ['upDown', '浮いている'], ['shake', '左右に揺れる'], ['hop', 'ジャンプしている']].forEach(([value, label]) => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: label });
        btn.addEventListener('click', () => {
          appendFlowOp({ kind: 'charAnim', slot: state.tempSlot, anim: value });
          state.tempSlot = null;
          setStage('menu');
        });
        actions.appendChild(btn);
      });

      const flipButton = createElement('button', { className: 'flat', type: 'button', textContent: '向きを変える' });
      flipButton.addEventListener('click', () => {
        appendFlowOp({ kind: 'charFlip', slot: state.tempSlot });
        state.tempSlot = null;
        setStage('menu');
      });
      actions.appendChild(flipButton);

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.tempSlot = null;
        setStage('menu');
      });
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }
    function renderChooseTextType() {
      const info = createElement('p', { textContent: '文章はナレーションか会話かを選びます。' });
      const actions = createElement('div', { className: 'stage-actions' });
      const narrationButton = createElement('button', { className: 'flat', type: 'button', textContent: 'ナレーション' });
      narrationButton.addEventListener('click', () => {
        state.textDraft = { type: 'text', narration: true, speaker: null, text: '' };
        setStage('addText');
      });
      const dialogButton = createElement('button', { className: 'flat', type: 'button', textContent: 'キャラのセリフ' });
      dialogButton.addEventListener('click', () => {
        state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
        setStage('chooseTextSpeaker');
      });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.append(narrationButton, dialogButton, cancelButton);
      stageContainer.append(info, actions);
    }

    function renderChooseTextSpeaker() {
      const slots = Array.from(getActiveSlots());
      const info = createElement('p', { textContent: '話すキャラクターの位置を選びます。' });
      if (slots.length === 0) {
        const warn = createElement('p', { textContent: '舞台にキャラクターがいないため、真ん中で話す扱いになります。', className: 'log' });
        const confirm = createElement('button', { className: 'primary', type: 'button', textContent: '真ん中で話す' });
        confirm.addEventListener('click', () => {
          state.textDraft.speaker = 'center';
          setStage('addText');
        });
        const cancel = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
        cancel.addEventListener('click', () => setStage('menu'));
        stageContainer.append(info, warn, confirm, cancel);
        return;
      }

      const actions = createElement('div', { className: 'stage-actions' });
      slots.forEach(slot => {
        const btn = createElement('button', { className: 'flat', type: 'button', textContent: slotLabel(slot) });
        btn.addEventListener('click', () => {
          state.textDraft.speaker = slot;
          setStage('addText');
        });
        actions.appendChild(btn);
      });

      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.appendChild(cancelButton);

      stageContainer.append(info, actions);
    }

    function renderAddText() {
      const isNarration = state.textDraft.narration;
      const info = createElement('p', { textContent: isNarration ? 'ナレーションの文章を入力します。' : `${slotLabel(state.textDraft.speaker)}のセリフを入力します。` });
      const textarea = createElement('textarea');
      textarea.value = state.textDraft.text || '';
      textarea.placeholder = isNarration ? '例: こうして冒険は始まった。' : '例: さあ、行こう！';
      textarea.addEventListener('input', () => {
        state.textDraft.text = textarea.value;
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
        setStage('menu');
      });

      const addButton = createElement('button', { className: 'primary', type: 'button', textContent: '文章を追加' });
      addButton.disabled = !(state.textDraft.text || '').trim();
      addButton.addEventListener('click', () => {
        if (!(state.textDraft.text || '').trim()) {
          alert('文章を入力してください。');
          return;
        }
        const op = {
          kind: 'text',
          text: state.textDraft.text.trim(),
          narration: state.textDraft.narration,
          slot: state.textDraft.narration ? null : state.textDraft.speaker || 'center'
        };
        appendFlowOp(op);
        state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
        setStage('menu');
      });

      actions.append(cancelButton, addButton);
      stageContainer.append(info, textarea, actions);
    }

    function renderAddWait() {
      const info = createElement('p', { textContent: '何秒待つか入力してください。' });
      const waitInput = createElement('input', { type: 'number', min: 0.5, step: 0.5, value: 1.0 });
      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      const addButton = createElement('button', { className: 'primary', type: 'button', textContent: '待機を追加' });
      addButton.addEventListener('click', () => {
        const sec = parseFloat(waitInput.value);
        if (!Number.isFinite(sec) || sec <= 0) {
          alert('正しい秒数を入力してください。');
          return;
        }
        appendFlowOp({ kind: 'wait', seconds: sec });
        setStage('menu');
      });
      actions.append(cancelButton, addButton);
      stageContainer.append(info, waitInput, actions);
    }

    function renderChangeBackground() {
      if (!state.pendingBackgroundChange) {
        state.pendingBackgroundChange = { type: '', youtubeId: '', assetKey: null, assetURL: '' };
      }
      const info = createElement('p', { textContent: '変更後の背景を選択します。' });
      const typeLabel = createElement('label', { textContent: '背景タイプ' });
      const typeSelect = createElement('select');
      ['', 'youtube', 'image'].forEach(value => {
        const option = createElement('option', { value, textContent: value === '' ? '選択してください' : (value === 'youtube' ? 'YouTube' : '画像') });
        if (state.pendingBackgroundChange.type === value) option.selected = true;
        typeSelect.appendChild(option);
      });

      const youtubeLabel = createElement('label', { htmlFor: 'change-bg-youtube', textContent: 'YouTubeリンクまたはID' });
      const youtubeInput = createElement('input', { type: 'text', id: 'change-bg-youtube', value: state.pendingBackgroundChange.youtubeId, placeholder: 'https://youtu.be/...' });

      const imageLabel = createElement('label', { htmlFor: 'change-bg-image', textContent: '背景画像 (アップロード)' });
      const imageInput = createElement('input', { type: 'file', id: 'change-bg-image', accept: 'image/*' });

      const imageURLLabel = createElement('label', { htmlFor: 'change-bg-url', textContent: '背景画像URL' });
      const imageURLInput = createElement('input', { type: 'url', id: 'change-bg-url', value: state.pendingBackgroundChange.assetURL, placeholder: 'https://example.com/background.png' });

      const updateVisibility = () => {
        const type = typeSelect.value;
        youtubeLabel.style.display = youtubeInput.style.display = type === 'youtube' ? 'block' : 'none';
        imageLabel.style.display = imageInput.style.display = type === 'image' ? 'block' : 'none';
        imageURLLabel.style.display = imageURLInput.style.display = type === 'image' ? 'block' : 'none';
      };
      updateVisibility();

      typeSelect.addEventListener('change', () => {
        state.pendingBackgroundChange.type = typeSelect.value;
        if (typeSelect.value !== 'youtube') state.pendingBackgroundChange.youtubeId = '';
        if (typeSelect.value !== 'image') {
          state.pendingBackgroundChange.assetKey = null;
          state.pendingBackgroundChange.assetURL = '';
        }
        updateVisibility();
      });

      youtubeInput.addEventListener('input', () => {
        state.pendingBackgroundChange.youtubeId = youtubeInput.value.trim();
      });

      imageURLInput.addEventListener('input', () => {
        state.pendingBackgroundChange.assetURL = imageURLInput.value.trim();
      });

      imageInput.addEventListener('change', async () => {
        const file = imageInput.files?.[0];
        if (!file) return;
        const dataUrl = await fileToDataURL(file);
        state.pendingBackgroundChange.assetKey = storeAsset(dataUrl, 'background', file.name);
        state.pendingBackgroundChange.assetURL = '';
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.pendingBackgroundChange = null;
        setStage('menu');
      });

      const nextButton = createElement('button', { className: 'primary', type: 'button', textContent: 'トランジションを選ぶ' });
      nextButton.addEventListener('click', () => {
        if (!state.pendingBackgroundChange) return;
        const type = state.pendingBackgroundChange.type;
        if (type === 'youtube' && !extractYouTubeID(state.pendingBackgroundChange.youtubeId)) {
          alert('有効なYouTubeリンクまたはIDを入力してください。');
          return;
        }
        if (type === 'image' && !state.pendingBackgroundChange.assetKey && !state.pendingBackgroundChange.assetURL) {
          alert('画像をアップロードするかURLを入力してください。');
          return;
        }
        setStage('chooseTransition');
      });

      actions.append(cancelButton, nextButton);
      stageContainer.append(info, typeLabel, typeSelect, youtubeLabel, youtubeInput, imageLabel, imageInput, imageURLLabel, imageURLInput, actions);
    }
    function renderChooseTransition() {
      if (!state.pendingBackgroundChange) {
        setStage('menu');
        return;
      }
      const info = createElement('p', { textContent: '背景変更時の演出を選んでください。' });
      const actions = createElement('div', { className: 'stage-actions' });
      const blurButton = createElement('button', { className: 'flat', type: 'button', textContent: 'ブラー' });
      blurButton.addEventListener('click', () => {
        appendBGChangeFromPending('blur');
      });
      const switchButton = createElement('button', { className: 'flat', type: 'button', textContent: '切り替え' });
      switchButton.addEventListener('click', () => {
        appendBGChangeFromPending('switch');
      });
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => {
        state.pendingBackgroundChange = null;
        setStage('menu');
      });
      actions.append(blurButton, switchButton, cancelButton);
      stageContainer.append(info, actions);
    }

    function renderChooseCover() {
      const info = createElement('p', { textContent: 'クエスト一覧に表示するトップ画像（サムネイル）を設定します。' });
      const current = createElement('p', { className: 'log', textContent: state.cover.assetKey ? `選択済み: asset://${state.cover.assetKey}` : (state.cover.url ? `選択済みURL: ${state.cover.url}` : '未設定') });
      const sourceLabel = createElement('label', { textContent: '指定方法' });
      const sourceSelect = createElement('select');
      ['upload', 'url'].forEach(value => {
        const option = createElement('option', { value, textContent: value === 'upload' ? '画像をアップロード' : '画像URLを入力' });
        if ((!state.cover.assetKey && state.cover.url) && value === 'url') option.selected = true;
        if (state.cover.assetKey && value === 'upload') option.selected = true;
        sourceSelect.appendChild(option);
      });

      const fileLabel = createElement('label', { htmlFor: 'cover-image-file', textContent: 'サムネイル画像' });
      const fileInput = createElement('input', { type: 'file', id: 'cover-image-file', accept: 'image/*' });
      const urlLabel = createElement('label', { htmlFor: 'cover-image-url', textContent: 'サムネイル画像URL' });
      const urlInput = createElement('input', { type: 'url', id: 'cover-image-url', value: state.cover.url, placeholder: 'https://example.com/cover.png' });

      const updateVisibility = () => {
        const type = sourceSelect.value;
        fileLabel.style.display = fileInput.style.display = type === 'upload' ? 'block' : 'none';
        urlLabel.style.display = urlInput.style.display = type === 'url' ? 'block' : 'none';
      };
      updateVisibility();

      sourceSelect.addEventListener('change', () => {
        updateVisibility();
      });

      urlInput.addEventListener('input', () => {
        state.cover.url = urlInput.value.trim();
        state.cover.assetKey = null;
        renderQuestPreview();
      });

      fileInput.addEventListener('change', async () => {
        const file = fileInput.files?.[0];
        if (!file) return;
        const dataUrl = await fileToDataURL(file);
        state.cover.assetKey = storeAsset(dataUrl, 'cover', file.name);
        state.cover.url = '';
        renderQuestPreview();
      });

      const actions = createElement('div', { className: 'stage-actions' });
      const backButton = createElement('button', { className: 'secondary', type: 'button', textContent: '戻る' });
      backButton.addEventListener('click', () => setStage('menu'));
      const doneButton = createElement('button', { className: 'primary', type: 'button', textContent: '完了' });
      doneButton.addEventListener('click', () => {
        if (sourceSelect.value === 'url' && !state.cover.url) {
          alert('URLを入力するか、アップロードを選択してください。');
          return;
        }
        if (sourceSelect.value === 'upload' && !state.cover.assetKey) {
          alert('画像をアップロードしてください。');
          return;
        }
        setStage('menu');
      });
      actions.append(backButton, doneButton);
      stageContainer.append(info, current, sourceLabel, sourceSelect, fileLabel, fileInput, urlLabel, urlInput, actions);
    }

    function renderAskThumbnail() {
      const info = createElement('p', { textContent: 'アプリでは最終確認画面です。JSONプレビューを確認し、必要であればサムネイルも設定してください。' });
      const summary = createElement('ul');
      summary.style.margin = '0';
      summary.style.paddingLeft = '1.25rem';
      summary.innerHTML = `
        <li>タイトル: ${state.title || '(未設定)'}</li>
        <li>背景: ${state.background.type || '(未設定)'}</li>
        <li>フロー数: ${state.flowOps.length}</li>
        <li>サムネイル: ${state.cover.assetKey ? 'asset://' + state.cover.assetKey : (state.cover.url || 'なし')}</li>
      `;
      const actions = createElement('div', { className: 'stage-actions' });
      const finishButton = createElement('button', { className: 'primary', type: 'button', textContent: '完了してメニューへ戻る' });
      finishButton.addEventListener('click', () => setStage('menu'));
      const coverButton = createElement('button', { className: 'flat', type: 'button', textContent: 'サムネイルを設定する' });
      coverButton.addEventListener('click', () => setStage('chooseCover'));
      const cancelButton = createElement('button', { className: 'secondary', type: 'button', textContent: 'キャンセル' });
      cancelButton.addEventListener('click', () => setStage('menu'));
      actions.append(finishButton, coverButton, cancelButton);
      stageContainer.append(info, summary, actions);
    }
    function appendBGChangeFromPending(transition) {
      if (!state.pendingBackgroundChange) return;
      const pending = state.pendingBackgroundChange;
      const type = pending.type;
      if (type === 'youtube') {
        const id = extractYouTubeID(pending.youtubeId);
        if (!id) {
          alert('有効なYouTubeリンクまたはIDを入力してください。');
          return;
        }
        appendFlowOp({ kind: 'bgYouTube', youtubeID: id, transition });
      } else if (type === 'image') {
        appendFlowOp({ kind: 'bgImage', assetKey: pending.assetKey, assetURL: pending.assetURL, transition });
      }
      state.pendingBackgroundChange = null;
      setStage('menu');
    }

    function appendFlowOp(op) {
      state.flowOps.push(op);
      renderTimeline();
      renderQuestPreview();
    }

    function getActiveSlots() {
      const active = new Set();
      state.flowOps.forEach(op => {
        switch (op.kind) {
          case 'charAdd':
            if (op.slot) active.add(op.slot);
            break;
          case 'charRemove':
            if (op.slot) active.delete(op.slot);
            break;
        }
      });
      return active;
    }

    function slotLabel(slot) {
      switch (slot) {
        case 'left':
          return '左';
        case 'center':
          return '真ん中';
        case 'right':
          return '右';
        default:
          return 'ナレーション';
      }
    }

    function storeAsset(dataUrl, kind, name) {
      const key = `${kind}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
      state.assets[key] = { dataUrl, kind, name };
      return key;
    }

    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(file);
      });
    }
    function renderTimeline() {
      timelineContainer.innerHTML = '';
      if (state.flowOps.length === 0) {
        const empty = createElement('p', { className: 'log', textContent: 'まだフローはありません。メニューから操作を追加してください。' });
        timelineContainer.appendChild(empty);
        return;
      }

      state.flowOps.forEach((op, index) => {
        const item = createElement('div', { className: 'timeline-item', role: 'listitem' });
        const textWrapper = createElement('div');
        const title = createElement('strong', { textContent: timelineTitle(op) });
        const subtitle = createElement('span', { textContent: timelineSubtitle(op) });
        textWrapper.append(title, subtitle);
        const removeButton = createElement('button', { className: 'danger', type: 'button', textContent: '削除' });
        removeButton.addEventListener('click', () => {
          state.flowOps.splice(index, 1);
          renderTimeline();
          renderQuestPreview();
        });
        item.append(textWrapper, removeButton);
        timelineContainer.appendChild(item);
      });
    }

    function timelineTitle(op) {
      switch (op.kind) {
        case 'charAdd':
          return `キャラ追加 (${slotLabel(op.slot)})`;
        case 'charRemove':
          return `キャラ退場 (${slotLabel(op.slot)})`;
        case 'charAnim':
          return `動き変更 (${slotLabel(op.slot)})`;
        case 'charFlip':
          return `向き変更 (${slotLabel(op.slot)})`;
        case 'text':
          return op.narration ? 'ナレーション' : `セリフ (${slotLabel(op.slot)})`;
        case 'wait':
          return 'ウェイト';
        case 'bgImage':
          return '背景変更 (画像)';
        case 'bgYouTube':
          return '背景変更 (YouTube)';
        default:
          return op.kind;
      }
    }

    function timelineSubtitle(op) {
      switch (op.kind) {
        case 'charAdd': {
          const scale = op.scale ? ` x${Number(op.scale).toFixed(2)}` : '';
          const source = op.assetURL ? op.assetURL : (op.assetKey ? `asset://${op.assetKey}` : '不明');
          return `${op.anim || 'none'}${scale} | ${source}`;
        }
        case 'charRemove':
          return '退場';
        case 'charAnim':
          return op.anim || 'none';
        case 'charFlip':
          return '左右反転';
        case 'text':
          return op.text || '';
        case 'wait':
          return `${op.seconds}s`;
        case 'bgImage':
          return `${op.transition || 'switch'} | ${op.assetURL || (op.assetKey ? 'asset://' + op.assetKey : '')}`;
        case 'bgYouTube':
          return `${op.transition || 'switch'} | ${op.youtubeID}`;
        default:
          return '';
      }
    }
    function extractYouTubeID(input) {
      if (!input) return '';
      const trimmed = input.trim();
      const direct = /^[a-zA-Z0-9_-]{11}$/;
      if (direct.test(trimmed)) return trimmed;
      const match = trimmed.match(/[?&]v=([a-zA-Z0-9_-]{11})/);
      if (match) return match[1];
      const short = trimmed.match(/youtu\.be\/([a-zA-Z0-9_-]{11})/);
      if (short) return short[1];
      return '';
    }

    function generateScriptLines() {
      const lines = [];
      state.flowOps.forEach(op => {
        switch (op.kind) {
          case 'text':
            if (!op.text) break;
            if (op.narration) {
              lines.push(':::textType(narration)');
              lines.push(op.text);
            } else {
              lines.push(':::textType(dialog)');
              const speaker = op.slot || 'center';
              lines.push(`:::speaker(${speaker})`);
              lines.push(op.text);
            }
            break;
          case 'wait':
            if (op.seconds != null) {
              lines.push(`:::wait(${Number(op.seconds)})`);
            }
            break;
          case 'charAdd': {
            const slot = op.slot || 'center';
            const anim = op.anim || 'none';
            const scale = Number(op.scale || 1).toFixed(2);
            const source = op.assetURL || (op.assetKey ? `asset://${op.assetKey}` : '');
            if (!source) break;
            lines.push(`:::charAdd(${slot},${source},${anim},${scale})`);
            break;
          }
          case 'charRemove':
            if (op.slot) lines.push(`:::charRemove(${op.slot})`);
            break;
          case 'charAnim':
            if (op.slot && op.anim) lines.push(`:::charAnim(${op.slot},${op.anim})`);
            break;
          case 'charFlip':
            if (op.slot) lines.push(`:::charFlip(${op.slot})`);
            break;
          case 'bgImage': {
            const source = op.assetURL || (op.assetKey ? `asset://${op.assetKey}` : '');
            if (!source) break;
            const transition = op.transition || 'switch';
            lines.push(`:::bgImage(${source},${transition})`);
            break;
          }
          case 'bgYouTube':
            if (op.youtubeID) {
              const transition = op.transition || 'switch';
              lines.push(`:::bgYouTube(${op.youtubeID},${transition})`);
            }
            break;
          default:
            break;
        }
      });
      return lines;
    }

    function collectQuest() {
      if (!state.title.trim()) return null;
      if (!isBackgroundReady(state.background)) return null;
      const bgType = state.background.type;
      let bgURL = '';
      if (bgType === 'youtube') {
        const id = extractYouTubeID(state.background.youtubeId);
        if (!id) return null;
        bgURL = id;
      } else if (bgType === 'image') {
        bgURL = state.background.assetURL || (state.background.assetKey ? `asset://${state.background.assetKey}` : '');
        if (!bgURL) return null;
      }

      const lines = generateScriptLines();
      const quest = {
        title: state.title.trim(),
        authorUID: state.authorUID || 'guest',
        bgType,
        bgURL,
        dialogLines: lines,
        flowOps: state.flowOps,
        assets: state.assets,
        cover: state.cover.assetKey ? { type: 'asset', key: state.cover.assetKey } : (state.cover.url ? { type: 'url', url: state.cover.url } : null),
        location: buildLocationPayload(),
        radius: Number(radiusInput.value) || 500
      };
      return quest;
    }

    function buildLocationPayload() {
      const mode = state.locationChoice.mode;
      const radius = Number(radiusInput.value) || 500;
      const payload = {
        mode,
        name: locationNameInput.value.trim() || null,
        detail: locationDetailInput.value.trim() || null,
        radius
      };
      if (mode === 'specific' && state.selectedCoordinate) {
        payload.latitude = Number(state.selectedCoordinate.latitude.toFixed(6));
        payload.longitude = Number(state.selectedCoordinate.longitude.toFixed(6));
      } else if (mode === 'current' && state.selectedCoordinate) {
        payload.latitude = Number(state.selectedCoordinate.latitude.toFixed(6));
        payload.longitude = Number(state.selectedCoordinate.longitude.toFixed(6));
      } else {
        payload.latitude = null;
        payload.longitude = null;
      }
      return payload;
    }

    function renderQuestPreview() {
      const quest = collectQuest();
      if (quest) {
        questPreview.textContent = JSON.stringify(quest, null, 2);
      } else {
        const fallback = {
          title: state.title,
          authorUID: state.authorUID,
          bgType: state.background.type,
          bgURL: state.background.type === 'youtube' ? state.background.youtubeId : state.background.assetURL || state.background.assetKey,
          dialogLines: generateScriptLines(),
          flowOps: state.flowOps,
          assets: state.assets,
          location: buildLocationPayload()
        };
        questPreview.textContent = JSON.stringify(fallback, null, 2);
      }
    }
    function shortUid(uid) {
      if (!uid) return '';
      return uid.length > 12 ? `${uid.slice(0, 6)}…${uid.slice(-4)}` : uid;
    }

    function initializeFirebase() {
      if (firebaseApp || firebaseInitError) {
        return;
      }
      if (typeof firebase === 'undefined') {
        firebaseInitError = new Error('Firebase SDK が読み込まれていません。');
        if (firebaseStatus) {
          firebaseStatus.textContent = firebaseInitError.message;
        }
        return;
      }
      try {
        const config = getActiveFirebaseConfig();
        if (!config || !config.apiKey) {
          if (firebaseStatus) {
            firebaseStatus.textContent = 'Firebase構成が未設定です。「Firebase設定」からWebアプリの構成を保存してください。';
          }
          return;
        }
        if (firebaseStatus) {
          const note = usingDefaultFirebaseConfig()
            ? 'FirebaseをiOSアプリ用のデフォルト構成で初期化しています。Web用の構成を保存するとこのメッセージは消えます。'
            : '保存済みのWeb構成でFirebaseを初期化しています。';
          firebaseStatus.textContent = note;
        }
        firebaseApp = firebase.apps.length ? firebase.app() : firebase.initializeApp(config);
        firebaseAuth = firebase.auth();
        firebaseFirestore = firebase.firestore();
        firebaseFirestore.settings({ ignoreUndefinedProperties: true });
        firebaseStorage = firebase.storage();
        if (firebaseStatus) {
          firebaseStatus.textContent = 'Firebaseを初期化しました。匿名サインインを実行しています…';
        }
        firebaseAuth.onAuthStateChanged(user => {
          if (user) {
            firebaseUserIdPreview = shortUid(user.uid);
            if (firebaseStatus) {
              firebaseStatus.textContent = `Firebaseにサインインしました（${firebaseUserIdPreview}）`;
            }
          } else if (firebaseStatus) {
            firebaseStatus.textContent = 'Firebaseのサインイン待機中です…';
          }
        });
        firebaseAuth.signInAnonymously().catch(error => {
          firebaseInitError = error;
          if (firebaseStatus) {
            firebaseStatus.textContent = `匿名サインインに失敗しました: ${error.message}`;
                        if (error.code === 'auth/admin-restricted-operation') {
              firebaseStatus.textContent += `\n${adminRestrictedGuidance()}`;
            } else if (error.code === 'auth/operation-not-allowed') {
              firebaseStatus.textContent += '\nFirebaseコンソールのAuthentication設定で匿名サインインを有効にしてください。';
            }
          }
          if (firebaseConfigLog) {
            if (error.code === 'auth/admin-restricted-operation') {
              firebaseConfigLog.textContent = `auth/admin-restricted-operation: ${adminRestrictedGuidance()}`;
            } else {
              firebaseConfigLog.textContent = `匿名サインインに失敗しました: ${error.message}`;
            }
          }
        });
      } catch (error) {
        firebaseInitError = error;
        if (firebaseStatus) {
          firebaseStatus.textContent = `Firebase初期化に失敗しました: ${error.message}`;
          if (error.code === 'auth/admin-restricted-operation') {
            firebaseStatus.textContent += `\n${adminRestrictedGuidance()}`;
          }
        }
        if (firebaseConfigLog && error.code === 'auth/admin-restricted-operation') {
          firebaseConfigLog.textContent = `auth/admin-restricted-operation: ${adminRestrictedGuidance()}`;
        }
      }
    }

    function waitForAuthUser(timeoutMs = 10000) {
      return new Promise((resolve, reject) => {
        if (firebaseAuth?.currentUser) {
          resolve(firebaseAuth.currentUser);
          return;
        }
        const startedAt = Date.now();
        const unsubscribe = firebaseAuth?.onAuthStateChanged(user => {
          if (user) {
            unsubscribe && unsubscribe();
            resolve(user);
          }
        }, error => {
          unsubscribe && unsubscribe();
          reject(error);
        });
        const timer = setInterval(() => {
          if (firebaseAuth?.currentUser) {
            clearInterval(timer);
            unsubscribe && unsubscribe();
            resolve(firebaseAuth.currentUser);
          } else if (Date.now() - startedAt > timeoutMs) {
            clearInterval(timer);
            unsubscribe && unsubscribe();
            reject(new Error('Firebaseのサインインがタイムアウトしました。'));
          }
        }, 250);
      });
    }

    async function ensureFirebaseReadyForUpload() {
      if (!firebaseApp && !firebaseInitError) {
        initializeFirebase();
      }
      if (firebaseInitError) {
        throw firebaseInitError;
      }
      if (!firebaseAuth || !firebaseFirestore || !firebaseStorage) {
        throw new Error('Firebaseの初期化が完了していません。');
      }
      if (!firebaseAuth.currentUser) {
        try {
          await firebaseAuth.signInAnonymously();
        } catch (error) {
        if (error?.code === 'auth/admin-restricted-operation') {
            throw new Error(`匿名サインインに失敗しました: ${error.message} — ${adminRestrictedGuidance()}`);
          }
          if (error?.code === 'auth/operation-not-allowed') {
            throw new Error(`匿名サインインに失敗しました: ${error.message} — FirebaseコンソールのAuthentication設定で匿名サインインを有効にしてください。`);
          }
          throw new Error(`匿名サインインに失敗しました: ${error.message}`);
        }
      }
      return waitForAuthUser();
    }

    function getRequiredAssetKeys() {
      const keys = new Set();
      if (state.background.type === 'image' && state.background.assetKey) {
        keys.add(state.background.assetKey);
      }
      if (state.cover.assetKey) {
        keys.add(state.cover.assetKey);
      }
      state.flowOps.forEach(op => {
        if ((op.kind === 'charAdd' || op.kind === 'bgImage') && op.assetKey) {
          keys.add(op.assetKey);
        }
      });
      return Array.from(keys);
    }

    function storageFolderForKind(kind) {
      switch (kind) {
        case 'background':
          return 'questBGs';
        case 'cover':
          return 'questCovers';
        case 'character':
        default:
          return 'questChars';
      }
    }

    async function uploadRequiredAssets(assetKeys) {
      const map = {};
      const total = assetKeys.length;
      for (let i = 0; i < assetKeys.length; i += 1) {
        const key = assetKeys[i];
        const asset = state.assets[key];
        if (!asset) {
          throw new Error(`ローカルアセットが見つかりません: ${key}`);
        }
        if (uploadLog) {
          uploadLog.textContent = `画像をアップロード中 (${i + 1}/${total})…`;
        }
        const url = await uploadSingleAsset(key, asset);
        map[key] = url;
      }
      return map;
    }

    async function uploadSingleAsset(key, asset) {
      const folder = storageFolderForKind(asset.kind);
      const { blob, contentType, extension } = await prepareAssetForUpload(asset);
      if (!blob) throw new Error('画像の変換でBlobが得られませんでした。');

      const fileName = `${key}-${Date.now().toString(36)}.${extension}`;
      const storageRef = firebaseStorage.ref().child(`${folder}/${fileName}`);

      return new Promise((resolve, reject) => {
        const task = storageRef.put(blob, {
          contentType,
          cacheControl: 'public, max-age=31536000, immutable'
        });

        task.on(
          firebase.storage.TaskEvent.STATE_CHANGED,
          snap => {
            if (uploadLog && snap.totalBytes > 0) {
              const pct = Math.round((snap.bytesTransferred / snap.totalBytes) * 100);
              uploadLog.textContent = `アップロード中: ${pct}% (${asset.kind})`;
            }
          },
          err => {
            console.error('Storage upload error:', err);
            reject(err);
          },
          async () => {
            try {
              const url = await storageRef.getDownloadURL();
              resolve(url);
            } catch (e) {
              reject(e);
            }
          }
        );
      const fileName = `${key}-${Date.now().toString(36)}.${extension}`;
      const ref = firebaseStorage.ref().child(`${folder}/${fileName}`);
      });
    }

    async function prepareAssetForUpload(asset) {
      const image = await loadImageFromDataUrl(asset.dataUrl);
      const maxLongSide = asset.kind === 'background' ? 1600 : asset.kind === 'cover' ? 640 : 768;
      const maxBytes = asset.kind === 'background' ? 1_400_000 : asset.kind === 'cover' ? 240_000 : 300_000;
      const preferPNG = asset.kind === 'character';
      let scale = Math.min(1, maxLongSide / Math.max(image.width, image.height));
      if (!Number.isFinite(scale) || scale <= 0) {
        scale = 1;
      }
      let quality = preferPNG ? 1 : 0.92;
      const mimeType = preferPNG ? 'image/png' : 'image/jpeg';
      let blob = await renderImageToBlob(image, scale, mimeType, quality);
      if (!blob) {
        throw new Error('画像の変換に失敗しました。');
      }
      if (!preferPNG) {
        while (blob.size > maxBytes && quality > 0.65) {
          quality = Math.max(0.65, quality - 0.07);
          const candidate = await renderImageToBlob(image, scale, mimeType, quality);
          if (!candidate) break;
          blob = candidate;
        }
      }
      while (blob.size > maxBytes && scale > 0.35) {
        scale *= 0.88;
        const candidate = await renderImageToBlob(image, scale, mimeType, preferPNG ? 1 : quality);
        if (!candidate) break;
        blob = candidate;
      }
      return {
        blob,
        contentType: mimeType,
        extension: preferPNG ? 'png' : 'jpg'
      };
    }

    function loadImageFromDataUrl(dataUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('画像の読み込みに失敗しました。'));
        img.src = dataUrl;
      });
    }

    function renderImageToBlob(image, scale, mimeType, quality) {
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(image.width * scale));
      canvas.height = Math.max(1, Math.round(image.height * scale));
      const ctx = canvas.getContext('2d');
      if (!ctx) return null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      return new Promise(resolve => {
        const q = typeof quality === 'number' ? quality : (mimeType === 'image/png' ? 1 : 0.92);
        try {
          canvas.toBlob(blob => {
            if (blob) {
              resolve(blob);
              return;
            }
            try {
              const dataURL = canvas.toDataURL(mimeType, q);
              const byteString = atob(dataURL.split(',')[1]);
              const ab = new ArrayBuffer(byteString.length);
              const ia = new Uint8Array(ab);
              for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
              resolve(new Blob([ab], { type: mimeType }));
            } catch {
              resolve(null);
            }
          }, mimeType, q);
        } catch {
          try {
            const dataURL = canvas.toDataURL(mimeType, q);
            const byteString = atob(dataURL.split(',')[1]);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
            resolve(new Blob([ab], { type: mimeType }));
          } catch {
            resolve(null);
          }
        }
      });
    }

    function generateFinalDialogLines(assetURLMap) {
      const lines = [];
      state.flowOps.forEach(op => {
        switch (op.kind) {
          case 'text':
            if (!op.text) break;
            if (op.narration) {
              lines.push(':::textType(narration)');
              lines.push(op.text);
            } else {
              lines.push(':::textType(dialog)');
              const speaker = op.slot || 'center';
              lines.push(`:::speaker(${speaker})`);
              lines.push(op.text);
            }
            break;
          case 'wait':
            if (op.seconds != null) {
              const sec = Number(op.seconds);
              lines.push(`:::wait(${Number.isFinite(sec) ? sec : op.seconds})`);
            }
            break;
          case 'charAdd': {
            const slot = op.slot || 'center';
            const anim = op.anim || 'none';
            const scale = Number(op.scale || 1).toFixed(2);
            const source = op.assetURL || (op.assetKey ? assetURLMap[op.assetKey] : '');
            if (!source) break;
            lines.push(`:::charAdd(${slot},${source},${anim},${scale})`);
            break;
          }
          case 'charRemove':
            if (op.slot) {
              lines.push(`:::charRemove(${op.slot})`);
            }
            break;
          case 'charAnim':
            if (op.slot && op.anim) {
              lines.push(`:::charAnim(${op.slot},${op.anim})`);
            }
            break;
          case 'charFlip':
            if (op.slot) {
              lines.push(`:::charFlip(${op.slot})`);
            }
            break;
          case 'bgImage': {
            const source = op.assetURL || (op.assetKey ? assetURLMap[op.assetKey] : '');
            if (!source) break;
            const transition = op.transition || 'switch';
            lines.push(`:::bgImage(${source},${transition})`);
            break;
          }
          case 'bgYouTube':
            if (op.youtubeID) {
              const transition = op.transition || 'switch';
              lines.push(`:::bgYouTube(${op.youtubeID},${transition})`);
            }
            break;
          default:
            break;
        }
      });
      return lines;
    }

    function resolveBackgroundURL(assetURLMap) {
      if (state.background.type === 'youtube') {
        const id = extractYouTubeID(state.background.youtubeId);
        return id || '';
      }
      if (state.background.type === 'image') {
        if (state.background.assetURL) {
          return state.background.assetURL;
        }
        if (state.background.assetKey && assetURLMap[state.background.assetKey]) {
          return assetURLMap[state.background.assetKey];
        }
      }
      return '';
    }

    function resolveCoverURL(assetURLMap) {
      if (state.cover.assetKey && assetURLMap[state.cover.assetKey]) {
        return assetURLMap[state.cover.assetKey];
      }
      if (state.cover.url) {
        return state.cover.url;
      }
      return '';
    }

    async function uploadQuestToFirebase(baseQuest) {
      const user = await ensureFirebaseReadyForUpload();
      const assetKeys = getRequiredAssetKeys();
      const assetURLMap = assetKeys.length > 0 ? await uploadRequiredAssets(assetKeys) : {};
      const backgroundURL = resolveBackgroundURL(assetURLMap);
      if (!backgroundURL) {
        throw new Error('背景のURLを決定できませんでした。画像またはYouTubeを確認してください。');
      }
      const coverURL = resolveCoverURL(assetURLMap);
      const dialogLines = generateFinalDialogLines(assetURLMap);
      const location = buildLocationPayload();
      const questDocument = {
        title: baseQuest.title.trim(),
        authorUID: user?.uid || baseQuest.authorUID || 'guest',
        bgType: state.background.type,
        bgURL: backgroundURL,
        charPosition: 'center',
        charAnim: 'none',
        dialogLines,
        coverURL: coverURL || '',
        charURL: '',
        placeType: 'dungeon',
        createdAt: firebase.firestore.Timestamp.fromDate(new Date()),
        locationMode: location.mode || 'everywhere',
        locationLatitude: typeof location.latitude === 'number' && Number.isFinite(location.latitude) ? location.latitude : null,
        locationLongitude: typeof location.longitude === 'number' && Number.isFinite(location.longitude) ? location.longitude : null,
        locationName: location.name || null,
        locationAddress: location.detail || null
      };

      const docRef = await firebaseFirestore.collection('quests').add(questDocument);
      return { id: docRef.id, questDocument };
    }

if (firebaseConfigSaveButton) {
      firebaseConfigSaveButton.addEventListener('click', async () => {
        const raw = firebaseConfigInput?.value?.trim() ?? '';
        if (!raw) {
          if (firebaseConfigLog) {
            firebaseConfigLog.textContent = 'Firebase構成のJSONを入力してください。';
          }
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          const validationError = validateFirebaseConfig(parsed);
          if (validationError) {
            if (firebaseConfigLog) {
              firebaseConfigLog.textContent = validationError;
            }
            return;
          }
          saveFirebaseConfig(parsed);
          updateFirebaseConfigEditor();
          if (firebaseConfigLog) {
            firebaseConfigLog.textContent = 'Firebase構成を保存しました。再接続を試みています…';
          }
          await reinitializeFirebase();
        } catch (error) {
          if (firebaseConfigLog) {
            firebaseConfigLog.textContent = `JSONの解析に失敗しました: ${error.message}`;
          }
        }
      });
    }

    if (firebaseConfigClearButton) {
      firebaseConfigClearButton.addEventListener('click', async () => {
        clearStoredFirebaseConfig();
        updateFirebaseConfigEditor();
        if (firebaseConfigLog) {
          firebaseConfigLog.textContent = '保存していたFirebase構成を削除しました。デフォルト構成で再接続します。';
        }
        await reinitializeFirebase();
      });
    }

    if (firebaseConfigTestButton) {
      firebaseConfigTestButton.addEventListener('click', async () => {
        if (firebaseConfigLog) {
          firebaseConfigLog.textContent = 'Firebaseへの接続を再試行しています…';
        }
        await reinitializeFirebase();
      });
    }

    document.getElementById('upload-quest').addEventListener('click', async () => {
      const quest = collectQuest();
      if (!quest) {
        uploadLog.textContent = '必須項目が不足しています。タイトル・背景・フローを確認してください。';
        return;
      }
      uploadLog.textContent = 'Firebaseと通信しています…';
      try {
        const { id } = await uploadQuestToFirebase(quest);
        uploadLog.textContent = `アップロードに成功しました。ドキュメントID: ${id}`;
      } catch (error) {
        console.error(error);
        let message = error?.message ?? String(error);
        if (error?.code === 'auth/admin-restricted-operation' && !message.includes('Firebaseコンソール')) {
          message += ` — ${adminRestrictedGuidance()}`;
        }
        uploadLog.textContent = `アップロードに失敗しました: ${message}`;
      }
    });

    document.getElementById('download-quest').addEventListener('click', () => {
      const quest = collectQuest();
      if (!quest) {
        uploadLog.textContent = 'JSONを出力するにはタイトル・背景・フローが必要です。';
        return;
      }
      const blob = new Blob([JSON.stringify(quest, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const safeTitle = quest.title.replace(/[^a-z0-9_-]+/gi, '_').toLowerCase() || 'quest';
      a.href = url;
      a.download = `${safeTitle}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      uploadLog.textContent = 'JSONファイルをダウンロードしました。';
    });

    document.getElementById('reset-all').addEventListener('click', () => {
      resetAll();
    });

    function resetAll() {
      state.stage = 'askTitle';
      state.title = '';
      state.authorUID = 'guest';
      state.background = { type: '', youtubeId: '', assetKey: null, assetURL: '' };
      state.flowOps = [];
      state.assets = {};
      state.cover = { assetKey: null, url: '' };
      state.textDraft = { type: 'text', narration: false, speaker: 'center', text: '' };
      state.charDraft = {};
      state.pendingBackgroundChange = null;
      state.tempSlot = null;
      state.locationChoice = { mode: 'everywhere', name: '', detail: '' };
      latitudeInput.value = '';
      longitudeInput.value = '';
      locationModeInputs.forEach(input => { input.checked = input.value === 'everywhere'; });
      locationNameInput.value = '';
      locationDetailInput.value = '';
      if (state.map && state.marker && typeof mapkit !== 'undefined') {
        state.map.removeAnnotation(state.marker);
        state.marker = null;
      }
      state.selectedCoordinate = null;
      renderStage();
      uploadLog.textContent = 'すべてリセットしました。';
      mapLog.textContent = '位置情報がリセットされました。';
    }

    document.getElementById('toggle-theme').addEventListener('click', () => {
      document.body.classList.toggle('dark');
      if (state.map && typeof mapkit !== 'undefined') {
        state.map.colorScheme = document.body.classList.contains('dark') ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light;
      }
    });

    document.getElementById('mapkit-init').addEventListener('click', () => {
      const token = document.getElementById('mapkit-token').value.trim();
      if (!token) {
        mapLog.textContent = 'JWTが入力されていません。';
        return;
      }
      if (typeof mapkit === 'undefined') {
        mapLog.textContent = 'MapKit JSが読み込まれていません。ネットワーク接続やスクリプトURLを確認してください。';
        return;
      }
      try {
        mapkit.init({ authorizationCallback: done => done(token) });
        state.map = new mapkit.Map('map', {
          colorScheme: document.body.classList.contains('dark') ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light
        });
        state.map.addEventListener('singleTap', event => {
          if (state.locationChoice.mode !== 'specific') return;
          const { latitude, longitude } = event.coordinate;
          setQuestLocation(latitude, longitude);
        });
        const lat = parseFloat(latitudeInput.value) || 35.680959;
        const lon = parseFloat(longitudeInput.value) || 139.767307;
        const radius = parseFloat(radiusInput.value) || 500;
        focusMap(lat, lon, radius);
        mapLog.textContent = `マップを初期化しました。現在地: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      } catch (error) {
        console.error(error);
        mapLog.textContent = 'MapKitの初期化に失敗しました。ブラウザのコンソールでエラーを確認してください。';
      }
    });

    function focusMap(latitude, longitude, radius) {
      if (!state.map || typeof mapkit === 'undefined') return;
      const coord = new mapkit.Coordinate(latitude, longitude);
      const span = radius / 111000;
      state.map.setRegion(new mapkit.CoordinateRegion(coord, new mapkit.CoordinateSpan(span, span)));
      setQuestLocation(latitude, longitude);
    }

    function setQuestLocation(latitude, longitude) {
      state.selectedCoordinate = { latitude, longitude };
      latitudeInput.value = latitude.toFixed(6);
      longitudeInput.value = longitude.toFixed(6);
      if (state.marker && state.map && typeof mapkit !== 'undefined') {
        state.map.removeAnnotation(state.marker);
      }
      if (state.map && typeof mapkit !== 'undefined') {
        state.marker = new mapkit.MarkerAnnotation(new mapkit.Coordinate(latitude, longitude), {
          title: state.title || 'クエストポイント',
          subtitle: 'タップで再設定できます',
          color: '#6c4cff'
        });
        state.map.addAnnotation(state.marker);
      }
      renderQuestPreview();
    }

    latitudeInput.addEventListener('change', () => {
      const lat = parseFloat(latitudeInput.value);
      const lon = parseFloat(longitudeInput.value);
      const radius = parseFloat(radiusInput.value) || 500;
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        focusMap(lat, lon, radius);
        mapLog.textContent = `緯度経度を手動設定: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      }
    });

    longitudeInput.addEventListener('change', () => {
      const lat = parseFloat(latitudeInput.value);
      const lon = parseFloat(longitudeInput.value);
      const radius = parseFloat(radiusInput.value) || 500;
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        focusMap(lat, lon, radius);
        mapLog.textContent = `緯度経度を手動設定: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      }
    });

    radiusInput.addEventListener('change', () => {
      const radius = parseFloat(radiusInput.value) || 500;
      if (state.selectedCoordinate) {
        focusMap(state.selectedCoordinate.latitude, state.selectedCoordinate.longitude, radius);
      }
      renderQuestPreview();
    });

    locationModeInputs.forEach(input => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        state.locationChoice.mode = input.value;
        if (input.value === 'everywhere') {
          state.selectedCoordinate = null;
          if (state.marker && state.map && typeof mapkit !== 'undefined') {
            state.map.removeAnnotation(state.marker);
            state.marker = null;
          }
          mapLog.textContent = 'すべての場所モードに切り替えました。';
        } else if (input.value === 'current') {
          mapLog.textContent = '現在地モードです。緯度経度を入力するか、マップで指定してください。';
        } else {
          mapLog.textContent = 'マップをタップして設置場所を指定してください。';
        }
        renderQuestPreview();
      });
    });

    locationNameInput.addEventListener('input', renderQuestPreview);
    locationDetailInput.addEventListener('input', renderQuestPreview);

    updateFirebaseConfigEditor();
    initializeFirebase();
    setStage('askTitle');
  </script>
</body>
</html>
